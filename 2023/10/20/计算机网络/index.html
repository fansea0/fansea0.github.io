<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>计算机网络 | FANSEA</title><meta name="keywords" content="计算机基础"><meta name="author" content="FANSEA"><meta name="copyright" content="FANSEA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="计算机网络"><meta name="application-name" content="计算机网络"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="计算机网络"><meta property="og:url" content="https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><meta property="og:site_name" content="FANSEA"><meta property="og:description" content="计算机网络网络分层模型OSI7层模型 应用层：为用户提供服务，例如查看用户信息 表示层：做数据压缩、加密 会话层：管理应用程序之间的会话 传输层：数据传输 网络层：IP、路由器构成的网络体系，用于定位资源最终目的地 数据链路层：帧校验纠正 物理层：传输比特流    TCP&amp;#x2F;IP网络模型 应"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://fansea0.github.io/fansea.png"><meta property="article:author" content="FANSEA"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://fansea0.github.io/fansea.png"><meta name="description" content="计算机网络网络分层模型OSI7层模型 应用层：为用户提供服务，例如查看用户信息 表示层：做数据压缩、加密 会话层：管理应用程序之间的会话 传输层：数据传输 网络层：IP、路由器构成的网络体系，用于定位资源最终目的地 数据链路层：帧校验纠正 物理层：传输比特流    TCP&amp;#x2F;IP网络模型 应"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: FANSEA","link":"链接: ","source":"来源: FANSEA","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'FANSEA',
  title: '计算机网络',
  postAI: '',
  pageFillDescription: '计算机网络, 网络分层模型, OSI7层模型, TCPx2FIP网络模型, 交换机和网关, TCP协议, 三次握手, 四次挥手, , , 超时重传, 快重传 快恢复, , HTTP, HTTP字段, GET 与 POST, HTTP版本对比, HTTP 1.0, HTTP 1.1, HTTP 2.0, HTTP 3.0, HTTP1.0和HTTP1.1, HTTP2, HTTPx2F3 做了哪些优化？, HTTP 缓存技术, HTTP 缓存实现方式, 什么是强制缓存？, 什么是协商缓存？, http与https, 不同点, , 网络层, UDP, TCP, ARP, NAT, 粘包问题, 什么是粘包问题, 如何解决粘包, 固定长度的消息, 特殊字符作为边界, 自定义消息结构, 总结, 思考, 国内访问国外网站这个过程发生了什么？, TCP和UDP的区别, DDOS攻击计算机网络网络分层模型层模型应用层为用户提供服务例如查看用户信息表示层做数据压缩加密会话层管理应用程序之间的会话传输层数据传输网络层路由器构成的网络体系用于定位资源最终目的地数据链路层帧校验纠正物理层传输比特流网络模型应用层应用层表示层会话层传输层网络层网络接口层数据链路层物理层交换机和网关交换机是一种网络设备主要用于实现局域网内的数据传输它通过对电光信号进行转发为接入交换机的任意两个网络节点提供独享的电信号通路交换机工作在参考模型的第二层数据链路层通常用于构建以太网并在二层网络交换中发挥重要作用网关是一个连接两个网络的设备它在不同的协议之间传递数据网关在网络间转递数据包但主机不能转送数据包它主要用于连接两个不同的网络如连接网络和以太网网关能在不同协议间移动数据类似于传统的网关协议传输控制协议是一种面向连接的可靠的基于字节流的传输层通信协议和包都是主动发的三次握手参数含义告诉对方我这是个连接请求表示收到表示当前传输的数据列表示确认收到内容之前的内容了请你从开始发给我数据为什么不是两次握手三次握手多了一个确认该连接请求是否是最新的连接请求的中间状态而两次握手会让服务端收到客户端的后立刻进入连接状态无法判断是否是历史连接核心原因避免重复连接如果客户端只需要发一次请求的功夫就能建立连接那如果客户端刚发连接请求网络阻塞了但因为我们是两次握手此时服务器端就会进入已连接状态但是等不到客户端请求浪费资源不说还可能因为客户端复活之后再发一次握手建立重复连接避免历史连接的原理重发的和原有的是不一样的依赖这个可以判断服务端返回的是否是最新的这样就可以屏蔽旧的连接请求四次挥手可以是三次挥手吗开启延迟机制并且没有数据发送时这样就可以把第二次和第三次合并成一个请求为什么是为了保证客户端发送的最后一个报文段能够到达服务器因为这个有可能丢失从而导致处在状态的服务器收不到对的确认报文服务器会超时重传这个接着客户端再重传一次确认重新启动时间等待计时器最后客户端和服务器都能正常的关闭假设客户端不等待而是在发送完之后直接释放关闭一但这个丢失的话服务器就无法正常的进入关闭连接状态个中的第一个是为了提供超时重传的保障而第二是在保证能到达被动端的前提下保证通信双方所有滞留在网络上的报文失效不会影响下一次通信流量控制作用为了解决发送方和接收方速度不同而导致的数据丢失问题当发送方发送的太快接收方来不及接受就会导致数据丢失方式由接收端采用滑动窗口的形式告知发送方允许停止发包解决丢包问题滑动窗口通过接受主机响应的字段来限定下一个包的长度字段表示的是接收主机目前可用的缓冲区大小保障发送端速率过快接收端从而缓冲区堆满导致的丢包现象窗口探测窗口更新如果窗口为了发送端会等待一段时间再向接收端发送一个探测的信息获取是否已经有空间可以传输了拥塞控制作用为了解决过多的数据注入到网络导致网络崩溃和超负荷问题方式由发送方采用拥塞窗口的形式去判断网络状态从而采取不同算法执行动态发包解决网络整体质量问题先了解两个概念拥塞窗口发送方维持的一个状态变量其大小取决于网络的拥塞程度并且动态变化慢开始门限为了防止拥塞窗口的增长过大引起网络拥塞所设置的一个门限值超时重传当发送端未收到接收端的确认消息客户端将触发超时重传这就可以认定当前网络出现了拥塞于是调整为当前的一半将值调整到重新进行慢开始这里的确认消息是需要等到接收端向发送端发送消息时捎过去的慢开始拥塞避免逐步加一避免增长过快超时重传年版本已废弃不用缺点对丢包敏感个别的报文段丢失就会认为网络发生阻塞但实际上网络并未发生阻塞于是发送方把陡然减小为并错误的开始执行慢算法因此降低了传输效率快重传快恢复快重传要求接收方收到消息后立即返回确认当接收方收不到其他的包的时候接收方会对收到的最近的包重复进行三次确认发送方接收到这三次确认就会知道网络段出现了部分丢包则此时进行快恢复快恢复是将同样降低为的一半这样并不会从开始执行慢开始算法并在此时执行拥塞避免算法快重传的三次确认机制让发送端更快地响应丢包的拥塞时间快重传快恢复对于个别丢失报文发送方不会出现超时等待也不会误以为出现了拥塞错误的把设置为实践证明此机制可以使整个网络吞吐量增加可靠传输数据包不一致的可能原因传输控制协议是一种面向连接的可靠的基于字节流的传输层通信协议它设计用于通过不可靠的网络提供可靠的数据传输服务然而在实际应用中可能会遇到数据包不一致的问题这些问题通常由以下几个原因造成网络拥塞当网络中的数据流量超过其承载能力时会导致数据包丢失或延迟进而影响到连接的数据一致性数据包丢失在数据传输过程中由于路由器故障线路质量差等原因可能导致某些数据包无法到达接收方通过序列号来检查丢失的数据包并请求重传数据包乱序在网络传输中不同的数据包可能通过不同的路径到达目的地这可能导致数据包到达顺序与发送顺序不同会根据每个数据包的序列号重新排序确保数据的正确性数据包损坏在传输过程中由于各种物理因素如电磁干扰等数据包内容可能会发生改变使用校验和来检测这种错误如果发现数据包损坏则会丢弃该数据包并请求重传面向连接可靠的前提校验和发送方将数据相加计算出来校验和填补到头部接受方对数据校验和重新计算对比头部校验和如果相等则数据正确该方法可以校验数据在传输中因为电磁干扰等问题导致的数据包损坏的问题超时重传机制序列号检测丢包拥塞控制控制流量减少阻塞字段字段客户端发送请求时用来指定服务器的域名有了字段就可以将请求发往同一台服务器上的不同网站字段服务器在返回数据时会有字段表明本次回应的数据长度如上面则是告诉浏览器本次服务器回应的数据长度是个字节后面的字节就属于下一个回应了大家应该都知道是基于传输协议进行通信的而使用了传输协议就会存在一个粘包的问题协议通过设置回车符换行符作为的边界通过字段作为的边界这两个方式都是为了解决粘包的问题具体什么是粘包可以看这篇文章如何理解是面向字节流协议字段字段最常用于客户端要求服务器使用长连接机制以便其他请求复用长连接的特点是只要任意一端没有明确提出断开连接则保持连接状态版本的默认连接都是长连接但为了兼容老版本的需要指定首部字段的值为开启了机制后连接就不会中断而是保持连接当客户端发送另一个请求时它会使用同一个连接一直持续到客户端或服务器端提出断开连接大家不要把和搞混了这两个虽然长的像但是不是一个东西具体可以看我这篇文章和是一个东西吗字段字段用于服务器回应时告诉客户端本次数据是什么格式上面的类型表明发送的是网页而且编码是客户端请求的时候可以使用字段声明自己可以接受哪些数据格式上面代码中客户端声明自己可以接受任何格式的数据字段字段说明数据的压缩方法表示服务器返回的数据使用了什么压缩格式上面表示服务器返回的数据采用了方式压缩告知客户端需要用此方式解压客户端在请求时用字段说明自己可以接受哪些压缩方法与不能说比安全因为他们的参数都可以通过报文看到和其实是的定义规范所以一个请求无论是否是也能在请求体携带参数版本对比缺乏长连接和管道支持每个对象都需要单独的连接状态管理缺乏持久连接这意味着每次请求都需要建立一个新的连接这增加了网络开销缓存处理提供了简单的缓存验证机制但没有明确的过期规则或缓存协调性能限制由于缺乏管道化支持每个对象都需要单独的连接这在多对象页面上表现不佳长连接多请求同时发送无需等待响应压缩请求体内容缺点是头部未压缩管道解决了请求的队头阻塞但是没有解决响应的队头阻塞持久连接默认启用了持久连接并引入了流水线处理允许多个请求同时发送而无需等待响应缓存改进提供了更复杂的缓存处理规则包括条件请求和更强的缓存一致性带宽优化通过允许使用编码压缩来减少带宽消耗缺点请求响应头部未经压缩就发送首部信息越多延迟越大只能压缩的部分发送冗长的首部每次互相发送相同的首部造成的浪费较多并发传输头部压缩服务推送二进制格式解析效率可靠性多路复用通过单一的连接支持多个并行操作而不是为每个请求建立单独的连接头部压缩使用算法对头部进行压缩减少了头部信息传输的开销服务端推送服务器可以预测客户端可能需要的资源并提前发送减少了延迟二进制格式使用二进制而非文本格式提高了协议解析效率和可靠性基于减少延迟基于基于之上的协议而不是像之前的版本那样基于提供了类似的功能但是减少了握手延迟提高了恢复速度连接迁移支持无缝连接迁移比如当设备在网络间切换时不会断开连接降低延迟减少了往返时间特别是在移动设备和高延迟网络环境中加密默认使用加密提供了更好的安全性和相比性能上的改进使用长连接的方式改善了短连接造成的性能开销支持管道网络传输只要第一个请求发出去了不必等其回来就可以发第二个请求出去可以减少整体的响应时间但还是有性能瓶颈请求响应头部未经压缩就发送首部信息越多延迟越大只能压缩的部分发送冗长的首部每次互相发送相同的首部造成的浪费较多服务器是按请求的顺序响应的如果服务器响应慢会招致客户端一直请求不到数据也就是队头阻塞没有请求优先级控制请求只能从客户端开始服务器只能被动响应协议是基于的所以的安全性也是有保障的那相比性能上的改进头部压缩将请求头记录为索引号二进制格式增加传输效率压缩传输体积并发传输技术针对不同的请求用独一无二的来区分接收端可以通过有序组装成消息不同的帧是可以乱序发送的因此可以并发不同的也就是可以并行交错地发送请求和响应服务器主动推送资源缺点以及建立连接的延时的队头阻塞并没有彻底解决虽然通过多个请求复用一个连接解决了的队头阻塞但是一旦发生丢包就会阻塞住所有的请求这属于层队头阻塞多路复用导致服务器压力上升多路复用容易做了哪些优化使用发送是不管顺序也不管丢包的所以不会出现像队头阻塞的问题大家都知道是不可靠传输的但基于的协议可以实现类似的可靠性传输有以下个特点无队头阻塞更快的连接建立连接迁移缓存技术缓存实现方式强制缓存多次请求数据一样就会在本地建立缓存并设置过期时间协商缓存一个请求已经访问过一次了下次访问请求缓存如果已经过期则携带向服务器请求数据比对是否相同如果相同返回并将缓存数据返回在这里类似于版本号对于一些具有重复性的请求比如每次请求得到的数据都一样的我们可以把这对请求响应的数据都缓存在本地那么下次就直接读取本地的数据不必在通过网络获取服务器的响应了这样的话的性能肯定肉眼可见的提升所以避免发送请求的方法就是通过缓存技术设计者早在之前就考虑到了这点因此协议的头部有不少是针对缓存的字段缓存有两种实现方式分别是强制缓存和协商缓存什么是强制缓存对应的请求产生在浏览器的缓存没有过期浏览器强制使用该缓存强缓存指的是只要浏览器判断缓存没有过期则直接使用浏览器的本地缓存决定是否使用缓存的主动性在于浏览器这边如下图中返回的是状态码但在项中标识的是就是使用了强制缓存强缓存是利用下面这两个响应头部字段实现的它们都用来表示资源在客户端缓存的有效期是一个相对时间是一个绝对时间如果响应头部同时有和字段的话的优先级高于选项更多一些设置更加精细所以建议使用来实现强缓存具体的实现流程如下当浏览器第一次请求访问服务器资源时服务器会在返回这个资源的同时在头部加上中设置了过期时间大小浏览器再次请求访问服务器中的该资源时会先通过请求资源的时间与中设置的过期时间大小来计算出该资源是否过期如果没有则使用该缓存否则重新请求服务器服务器再次收到请求后会再次更新头部的什么是协商缓存协商缓存就是与服务端协商之后通过协商结果来判断是否使用本地缓存发现本地缓存过期了向服务器协商是否过期缓存可以使用如果可以使用则直接返回本地缓存的数据当我们在浏览器使用开发者工具的时候你可能会看到过某些请求的响应码是这个是告诉浏览器可以使用本地缓存的资源通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存上图就是一个协商缓存的过程所以协商缓存就是与服务端协商之后通过协商结果来判断是否使用本地缓存注意协商缓存这两个字段都需要配合强制缓存中字段来使用只有在未能命中强制缓存的时候才能发起带有协商缓存字段的请求下图是强制缓存和协商缓存的工作流程当使用字段实现的协商缓存的过程当浏览器第一次请求访问服务器资源时服务器会在返回这个资源的同时在头部加上唯一标识这个唯一标识的值是根据当前请求的资源生成的当浏览器再次请求访问服务器中的该资源时首先会先检查强制缓存是否过期如果没有过期则直接使用本地缓存如果缓存过期了会在头部加上字段该字段的值就是唯一标识服务器再次收到请求后会根据请求中的值与当前请求的资源生成的唯一标识进行比较如果值相等则返回不会返回资源如果不相等则返回状态码和返回资源并在头部加上新的唯一标识如果浏览器收到的请求响应状态码则会从本地缓存中加载资源否则更新资源与不同点和使用的端口分别为为加密传输需要向证书权威机构申请数字证书来保证服务器的身份是可信的在与层之间加入了协议可以很好的解决了上述的风险信息加密交互信息无法被窃取交互信息由明文转变为密文校验机制无法篡改通信内容保证你看到的都是服务器提供的安全的信息身份证书证明淘宝是真的淘宝网证明网站的正规是如何实现的呢是如何解决上面的三个风险的混合加密的方式实现信息的机密性解决了窃听的风险摘要算法的方式来实现完整性它能够为数据生成独一无二的指纹指纹用于校验数据的完整性解决了篡改的风险将服务器公钥放入到数字证书中解决了冒充的风险混合加密客户端发送支持的非加密套件列表并传递浏览器随机数这里的浏览器随机数是用来最后生成公钥使用的服务端返回对应的加密套件并把服务端的随机数公钥返回给客户端最后客户端生成给服务端服务端使用私钥解密这时两方同时具备这三个随机数生成共同的公钥共同公钥用于非对称加密摘要算法保障数据不被篡改简单来说就是在发送内容的时候计算出原内容的值送到服务端继续计算值比对但是并不能保证内容哈希值不会被中间人替换因为这里缺少对客户端收到的消息是否来源于服务端的证明数字证书数字证书是由内容做完运算得到的值再使用私钥对其加密得到数字签名私钥是只有服务器有的对应的公钥才能解密确保解决了冒充风险通过数字证书的方式保证服务器公钥的身份解决冒充的风险网络层无连接只知道对端的和端口号就可以发送不需要实现建立连接就像寄信不可靠没有确认机制没有重传机制如果因为网络故障该段无法发到对方协议层也不会给应用层返回任何错误信息面向数据报应用层交给多长的报文原样发送既不会拆分也不会合并所以不能够灵活的控制读写数据的次数和数量存在接收缓冲区但不存在发送缓冲区没有发送缓冲区在调用时会直接将数据交给内核由内核将数据传给网络层协议进行后续的传输动作具有接收缓冲区但是这个接收缓冲区不能保证收到的报文的顺序和发送报的顺序一致如果缓冲区满了再到达的数据报就会被丢弃为什么不需要发送缓冲区因为不保证可靠性它没有重传机制当报文丢失时不需要重新发送而不同他必须具备发送缓冲区当报文丢失时必须保证重新发送用户不会管所以必须要具备发送缓冲区大小受限协议首部中有一个位的最大长度也就是说一个能传输的数据最大长度是包含首部优点低时延开销小广播通信无连接开销小没有复杂的可靠机制时延低多人在线游戏对延迟非常敏感的低延迟特性非常适合支持一对多广播通信面向连接要求建立连接三次握手并在数据传输完成后断开连接四次挥手可靠性重传机制错误检测如果检测到错误数据包将被丢弃发送方会在超时后重新发送丢失的数据包多路复用支持在同一连接上进行多个数据流的传输流量控制使用滑动窗口机制来进行流量控制防止发送方发送数据的速度超过接收方处理的能力定义为地址解析协议介于网络层和数据链路层之间用于转换将地址转化为设备的地址特点广播问询单播响应工作流程当局域网内主机需要向另外一个主机发送数据包在网络层已经知道主机的查询本机维护的的表查看是否能直接找到主机地址如果找不到则会发送广播数据包包含了需要得到对应的地址这时候局域网内所有的主机都会判断这个地址是否是自己如果不是则丢弃如果是则发送一个响应数据包带上自己的地址维护一张表保存的与映射发送到主机主机也会维护一张表保存的与映射最后进行物理寻址网络地址转换允许多台设备共享一个地址访问互联网作用是将局域网转换为公网减少公网地址的分配保障内部网络隐私和安全粘包问题什么是粘包问题主要关于数据的定界问题面向报文协议当用户消息通过协议传输时操作系统不会对消息进行拆分在组装好头部后就交给网络层来处理所以发出去的报文中的数据部分就是完整的用户消息也就是每个报文就是一个用户消息的边界这样接收方在接收到报文后读一个报文就能读取到完整的用户消息面向字节流的协议发送这两条消息时可能会被拆开发送所以就需要定界当用户消息通过协议传输时消息可能会被操作系统分组成多个的报文也就是一个完整的用户消息被拆分成多个报文进行传输如何解决粘包固定长度的消息这种是最简单方法即每个用户消息都是固定长度的比如规定一个消息的长度是个字节当接收方接满个字节就认为这个内容是一个完整且有效的消息但是这种方式灵活性不高实际中很少用特殊字符作为边界我们可以在两个用户消息之间插入一个特殊的字符串这样接收方在接收数据时读到了这个特殊字符就把认为已经读完一个完整的消息是一个非常好的例子通过设置回车符换行符作为报文协议的边界有一点要注意这个作为边界点的特殊字符如果刚好消息内容里有这个特殊字符我们要对这个字符转义避免被接收方当作消息的边界点而解析到无效的数据自定义消息结构我们可以自定义一个消息结构由包头和数据组成其中包头包是固定大小的而且包头里有一个字段来说明紧随其后的数据有多大比如这个消息结构体首先个字节大小的变量来表示数据长度真正的数据则在后面当接收方接收到包头的大小比如个字节后就解析包头的内容于是就可以知道数据的长度然后接下来就继续读取数据直到读满数据的长度就可以组装成一个完整到用户消息来处理了总结对于定长的数据包保证每次都按固定的大小读取即可对于变长的包可在包头的位置约定一个包总长度的字段从而就知道了包的结束位置对于变长的包还可以在包和包之间使用明确的分隔符应用层协议是我们自己写的只要保证分隔符不和正文冲突即可思考国内访问国外网站这个过程发生了什么发起请求用户在国内的电脑或移动设备上输入网址或发起访问请求域名解析查询用户的设备会向配置的服务器发送一个查询包询问该网址对应的地址服务器会返回对应的地址给用户的设备数据包传输至用户的设备通过网络接入设备如路由器将请求数据包发送到本地网络提供商转发至国际出口节点将请求数据包转发到国家本地的边界网关也称为国际出口节点这是连接国内网络和国际互联网的关键节点选择最佳国际出口通道边界网关会根据目标国际地址来选择最佳的国际出口通道或运营商并将请求数据包发送到该出口通道数据包进入国际互联网请求数据包从国内网络通过国际出口通道进入国际互联网然后经过一系列的路由器和网络节点进行传输到达目标国家当请求数据包到达目标国家之后它会经过该国家的边界网关然后进入目标国家的本地网络目标服务器响应目标国家的本地会将请求数据包传送给目标外网服务器目标外网服务器接收到请求数据包后会将响应数据包通过相同的路径返回给用户的设备数据包返回用户设备响应数据包沿着相同的路径通过边界网关国际出口通道和传回至用户的设备解析并显示内容用户的设备接收到响应数据包后解析其中的内容如果是网页设备会渲染并显示给用户如果是邮件则会在客户端上显示干货你还不知道路由器工作原理吗的人都看得懂图片干货你还不知道路由器工作原理吗的人都看得懂图片和的区别面向连接可靠重传机制基于字节流无连接不可靠大小受限基于数据报不存在发送缓冲区注定他没有重传机制但是他有接收缓冲区这个缓冲区不保障数据的顺序超过大小的数据也会被丢弃攻击分布式拒绝服务攻击与区别在于采用的是分布式攻击而单一机器的攻击攻击方法洪水将多台服务器向同一台服务器同时发送连接请求但是不进行最后的第三次握手导致服务器接收到大量的资源进入半连接的状态高频的请求导致每个请求都要访问数据库这种费事的操作在高频的执行下也会将服务器弄垮解决策略使用缓存设置访问黑名单微服务架构负载均衡拓展实现攻击找出网络中支持的主机通过对流量进行增大传输',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-10 20:12:31',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">FANSEA</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a><a href="/tags/MQ/" style="font-size: 1.05rem;">MQ<sup>1</sup></a><a href="/tags/NoSQL/" style="font-size: 1.05rem;">NoSQL<sup>2</sup></a><a href="/tags/ROS/" style="font-size: 1.05rem;">ROS<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>8</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E5%88%9B%E4%B8%9A/" style="font-size: 1.05rem;">创业<sup>1</sup></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">微服务<sup>4</sup></a><a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 1.05rem;">思考<sup>10</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 1.05rem;">技术<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/" style="font-size: 1.05rem;">技术漫谈<sup>21</sup></a><a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 1.05rem;">摄影<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>6</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>7</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>4</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A7%E5%88%B6/" style="font-size: 1.05rem;">计算机控制<sup>1</sup></a><a href="/tags/%E8%BD%A6%E8%BD%A6/" style="font-size: 1.05rem;">车车<sup>1</sup></a><a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 1.05rem;">金融<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>11</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机基础</span></a></span></div></div><h1 class="post-title" itemprop="name headline">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-20T10:52:09.000Z" title="发表于 2023-10-20 18:52:09">2023-10-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-04-10T12:12:31.642Z" title="更新于 2025-04-10 20:12:31">2025-04-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湘潭"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湘潭</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><header><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url">计算机基础</a><h1 id="CrawlerTitle" itemprop="name headline">计算机网络</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">FANSEA</span><time itemprop="dateCreated datePublished" datetime="2023-10-20T10:52:09.000Z" title="发表于 2023-10-20 18:52:09">2023-10-20</time><time itemprop="dateCreated datePublished" datetime="2025-04-10T12:12:31.642Z" title="更新于 2025-04-10 20:12:31">2025-04-10</time></header><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><h3 id="OSI7层模型"><a href="#OSI7层模型" class="headerlink" title="OSI7层模型"></a>OSI7层模型</h3><ul>
<li><strong>应用层</strong>：为用户提供服务，例如查看用户信息</li>
<li><strong>表示层</strong>：做数据压缩、加密</li>
<li><strong>会话层</strong>：管理应用程序之间的会话</li>
<li><strong>传输层</strong>：数据传输</li>
<li><strong>网络层</strong>：IP、路由器构成的网络体系，用于定位资源最终目的地</li>
<li><strong>数据链路层</strong>：帧校验纠正</li>
<li><strong>物理层</strong>：传输比特流</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20241021163451563.png" alt="image-20241021163451563"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240809090049967.png" alt="image-20240809090049967"></p>
<h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h3><ul>
<li>应用层（应用层、表示层、会话层）</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层（数据链路层、物理层）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/7.jpg"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20231020185556797.png" alt="image-20231020185556797"></p>
<h2 id="交换机和网关"><a href="#交换机和网关" class="headerlink" title="交换机和网关"></a>交换机和网关</h2><ul>
<li>交换机：是一种网络设备，主要用于实现局域网内的数据传输。它通过对电（光）信号进行转发，为接入交换机的任意两个网络节点提供独享的电信号通路。交换机工作在OSI参考模型的第二层（数据链路层），通常用于构建以太网并在二层网络交换中发挥重要作用。</li>
<li>网关：是一个连接两个网络的设备，它在不同的协议之间传递数据。网关在网络间转递数据包，但主机不能转送数据包。它主要用于连接两个不同的网络，如连接PSTN网络和以太网。网关能在不同协议间移动数据，类似于传统的IP网关。</li>
</ul>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>传输控制协议（<code>TCP</code>，<code>Transmission Control Protocol</code>）是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p>
<p><code>SYN</code>和<code>FIN</code>包都是主动发的</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul>
<li><code>C to S</code>：SYN&#x3D;1，Seq&#x3D;a</li>
<li><code>S to C</code>：SYN&#x3D;1，ACK&#x3D;1，Seq&#x3D;b，Ack&#x3D;a+1</li>
<li><code>C to S</code>：ACK&#x3D;1，Seq&#x3D;a+1，Ack&#x3D;b+1</li>
</ul>
<blockquote>
<p>参数含义：</p>
<ul>
<li>SYN：（<code>Synchronize</code>）告诉对方我这是个连接请求！</li>
<li>ACK：表示收到！Over，Over！</li>
<li>Seq：表示当前传输的数据列</li>
<li>Ack：表示确认收到ack内容之前的内容了，请你从ack开始发给我数据</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/2c936a2e13b410fd3b20399f09a20610.png" alt="2c936a2e13b410fd3b20399f09a20610"></p>
<blockquote>
<p><strong>为什么不是两次握手?</strong></p>
<p>三次握手多了一个<strong>确认该连接请求是否是最新的连接请求的中间状态</strong></p>
<p>而两次握手会让服务端收到客户端的SYN后立刻进入连接状态，无法判断是否是历史连接</p>
</blockquote>
<p>核心原因：<strong>避免重复连接</strong>！</p>
<p>如果客户端只需要发一次请求的功夫就能建立连接、那如果客户端刚发连接请求网络阻塞了，但因为我们是两次握手，此时服务器端就会进入已连接状态但是等不到客户端请求浪费资源不说，还可能因为客户端复活之后再发一次握手建立重复连接</p>
<p><strong>避免历史连接的原理</strong>：重发的SYN和原有的是不一样的，依赖这个可以判断服务端返回的SYN是否是最新的SYN，这样就可以屏蔽旧SYN的连接请求</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/format,png-20230309230525514.png" alt="format,png-20230309230525514"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul>
<li><code>C to S</code>：FIN&#x3D;1，ACK&#x3D;1，Seq&#x3D;x</li>
<li><code>S to C</code>：ACK&#x3D;1，Seq&#x3D;y，Ack&#x3D;x+1</li>
<li>waiting data transform complete………..</li>
<li><code>S to C</code>：FIN&#x3D;1，ACK&#x3D;1，Seq&#x3D;z，Ack&#x3D;x+1</li>
<li><code>C to S</code>：ACK&#x3D;1，Seq&#x3D;x+1，Ack&#x3D;z+1</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/a1275226b7c1cf09e2f60a1b81d5c300-1729488420270-1.png" alt="a1275226b7c1cf09e2f60a1b81d5c300"></p>
<blockquote>
<p><strong>可以是三次挥手吗？</strong></p>
</blockquote>
<p>开启<strong>TCP延迟机制、并且没有数据发送时</strong>这样就可以把第二次和第三次合并成一个请求！</p>
<blockquote>
<p>为什么是2MSL？</p>
</blockquote>
<p>1、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<p>2、2个MSL中的第一个MSL是为了提供超时重传的保障，而第二MSL是在保证ACK能到达被动端的前提下，保证通信双方所有滞留在网络上的报文失效，不会影响下一次通信</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41500064/article/details/135119715#:~:text=%E7%9B%AE%E5%BD%951%E3%80%81TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">流量控制</a></h3><ul>
<li><strong>作用：</strong>为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失；</li>
<li><strong>方式：</strong>由接收端采用滑动窗口的形式，告知发送方允许&#x2F;停止发包解决TCP丢包问题<ul>
<li><strong>滑动窗口</strong>：通过接受主机响应的<code>Window</code>字段来限定下一个包的长度，<code>Window</code>字段表示的是接收主机目前可用的缓冲区大小。保障发送端速率过快，接收端从而缓冲区堆满导致的丢包现象</li>
<li><strong>窗口探测&#x2F;窗口更新</strong>：如果窗口为0了，发送端会等待一段时间再向接收端发送一个探测的信息，获取是否已经有空间可以传输了</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/0292eb18c908d2588a2b531e3d235777.png" alt="0292eb18c908d2588a2b531e3d235777"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/156e776a3df0bca467855aff2e831908.png" alt="156e776a3df0bca467855aff2e831908"></p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41500064/article/details/135119715#:~:text=%E7%9B%AE%E5%BD%951%E3%80%81TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">拥塞控制</a></h3><p><strong>作用：</strong>为了解决过多的数据注入到网络导致网络崩溃和超负荷问题；</p>
<p><strong>方式：</strong>由发送方采用拥塞窗口的形式去判断网络状态，从而采取不同<a target="_blank" rel="noopener" href="https://edu.csdn.net/course/detail/40020?utm_source=glcblog&spm=1001.2101.3001.7020">算法</a>执行TCP动态发包解决网络整体质量问题</p>
<p>先了解两个概念：</p>
<p><strong>■ 拥塞窗口（cwnd）：</strong>发送方维持的一个状态变量，其大小取决于网络的拥塞程度，并且动态变化。</p>
<p><strong>■ 慢开始门限（ssthresh）：</strong>为了防止拥塞窗口cwnd的增长过大引起网络拥塞所设置的一个门限值。</p>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>当发送端未收到接收端的确认消息，客户端将触发超时重传， 这就可以认定当前网络出现了拥塞。于是ssthresh调整为当前cwnd的一半，将cwnd值调整到1，重新进行慢开始</p>
<blockquote>
<p>这里的确认消息是需要等到接收端向发送端发送消息时<strong>捎过去</strong>的</p>
</blockquote>
<p>■ 慢开始</p>
<p>■ 拥塞避免：逐步加一，避免增长过快</p>
<p>■ 超时重传（1988年TCP Tahoe版本，已废弃不用）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/08b3d6a4350e3893851fdd9536859a44.png" alt="08b3d6a4350e3893851fdd9536859a44"></p>
<p><strong>缺点：</strong></p>
<p>对丢包敏感，个别的TCP报文段丢失就会认为网络发生阻塞，但实际上网络并未发生阻塞。于是，发送方把cwnd陡然减小为1，并错误的开始执行慢算法，因此降低了传输效率</p>
<h4 id="快重传-快恢复"><a href="#快重传-快恢复" class="headerlink" title="快重传 快恢复"></a>快重传 快恢复</h4><p><strong>快重传</strong>要求接收方收到消息后立即返回确认，当接收方收不到其他的包的时候，接收方会对收到的最近的包重复进行三次确认。发送方接收到这三次确认就会知道<strong>网络段出现了部分丢包，则此时进行快恢复</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/788ee923a4ee9969a4fd4bf789c666b0.png" alt="788ee923a4ee9969a4fd4bf789c666b0"></p>
<p><strong>快恢复</strong>是将ssthresh同样降低为cwnd的一半，cwnd&#x3D;ssthresh，这样cwnd并不会从1开始执行慢开始算法。并在此时执行拥塞避免算法</p>
<blockquote>
<p><strong>快重传</strong>的三次确认机制让发送端更快地响应丢包的拥塞时间</p>
<p><strong>快重传+快恢复：</strong></p>
<p>对于个别丢失报文，发送方不会出现超时等待，也不会误以为出现了拥塞错误的把cwnd设置为1.实践证明，此机制可以使整个网络吞吐量增加<code>20%</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/8232aaab8eefd5b29f45d0d8a3d96114.png" alt="8232aaab8eefd5b29f45d0d8a3d96114"></p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuchenxia8/article/details/80428157">可靠传输</a></h3><p><strong>数据包不一致的可能原因：</strong></p>
<blockquote>
<p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它设计用于通过不可靠的网络提供可靠的数据传输服务。然而，在实际应用中，TCP可能会遇到数据包不一致的问题，这些问题通常由以下几个原因造成：</p>
<ol>
<li><strong>网络拥塞</strong>：当网络中的数据流量超过其承载能力时，会导致数据包丢失或延迟，进而影响到TCP连接的数据一致性。</li>
<li><strong>数据包丢失</strong>：在数据传输过程中，由于路由器故障、线路质量差等原因，可能导致某些数据包无法到达接收方。TCP通过序列号来检查丢失的数据包，并请求重传。</li>
<li><strong>数据包乱序</strong>：在网络传输中，不同的数据包可能通过不同的路径到达目的地，这可能导致数据包到达顺序与发送顺序不同。TCP会根据每个数据包的序列号重新排序，确保数据的正确性。</li>
<li><strong>数据包损坏</strong>：在传输过程中，由于各种物理因素（如电磁干扰等），数据包内容可能会发生改变。TCP使用校验和来检测这种错误，如果发现数据包损坏，则会丢弃该数据包并请求重传。</li>
</ol>
</blockquote>
<ul>
<li><strong>面向连接</strong>：可靠的前提</li>
<li><strong>校验和</strong>：发送方将数据相加计算出来校验和，填补到TCP头部，接受方对数据校验和重新计算，对比TCP头部校验和，如果相等则数据正确</li>
</ul>
<blockquote>
<p>该方法可以校验数据在传输中，因为电磁干扰等问题导致的数据包损坏的问题</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/46db3a77b5e13c9b86c9dc98e8271c3e.png" alt="46db3a77b5e13c9b86c9dc98e8271c3e"></p>
<ul>
<li><strong>超时重传机制：</strong>ACK序列号检测丢包</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/dddd2abd81104eac354a76bfc2e0269e.png" alt="dddd2abd81104eac354a76bfc2e0269e"></p>
<ul>
<li><strong>拥塞控制</strong>：控制流量减少阻塞</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP字段"><a href="#HTTP字段" class="headerlink" title="HTTP字段"></a>HTTP字段</h3><ol>
<li><em>Host</em> 字段</li>
</ol>
<p>客户端发送请求时，用来指定服务器的域名。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/7-HOST%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure>

<p>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p>
<ol start="2">
<li><em>Content-Length 字段</em></li>
</ol>
<p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/8-content-length%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure>

<p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p>
<p>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。具体什么是 TCP 粘包，可以看这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">如何理解是 TCP 面向字节流协议？(opens new window)</a></p>
<ol start="3">
<li><em>Connection 字段</em></li>
</ol>
<p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/d2b20d1cc03936332adb2a68512eb167-20230309231005893.png" alt="HTTP 长连接"></p>
<p>HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p>
<p>PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看我这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html">TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？(opens new window)</a></p>
<ol start="4">
<li><em>Content-Type 字段</em></li>
</ol>
<p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<ol start="5">
<li><em>Content-Encoding 字段</em></li>
</ol>
<p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p>
<p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>

<h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><blockquote>
<p>不能说GET比POST安全，因为他们的参数都可以通过报文看到！</p>
<p>Get和POST其实是RFC的定义规范，所以一个请求无论是否是GET也能在请求体携带参数</p>
</blockquote>
<h3 id="HTTP版本对比"><a href="#HTTP版本对比" class="headerlink" title="HTTP版本对比"></a>HTTP版本对比</h3><blockquote>
<h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>缺乏长连接、和管道支持每个对象都需要单独的TCP连接</p>
</blockquote>
<ul>
<li><strong>状态管理</strong>：HTTP 1.0缺乏持久连接，这意味着每次请求都需要建立一个新的TCP连接，这增加了网络开销。</li>
<li><strong>缓存处理</strong>：HTTP 1.0提供了简单的缓存验证机制，但没有明确的过期规则或缓存协调。</li>
<li><strong>性能限制</strong>：由于缺乏管道化支持，每个对象都需要单独的TCP连接，这在多对象页面上表现不佳。</li>
</ul>
<blockquote>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>长连接、多请求同时发送无需等待响应、压缩请求体内容；缺点是头部未压缩</p>
<p><strong>管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="17-管道网络传输"></p>
<ul>
<li><strong>持久连接</strong>：HTTP 1.1默认启用了持久连接，并引入了流水线处理，允许多个请求同时发送而无需等待响应。</li>
<li><strong>缓存改进</strong>：提供了更复杂的缓存处理规则，包括条件请求和更强的缓存一致性。</li>
<li><strong>带宽优化</strong>：通过允许<code>Body</code>使用编码压缩来减少带宽消耗。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
</ul>
<blockquote>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h4><p>并发传输、头部压缩、服务推送、二进制格式（解析效率、可靠性）</p>
</blockquote>
<ul>
<li><strong>多路复用</strong>：HTTP&#x2F;2通过单一的TCP连接支持多个并行操作，而不是为每个请求建立单独的连接。</li>
<li><strong>头部压缩</strong>：HTTP&#x2F;2使用HPACK算法对头部进行压缩，减少了头部信息传输的开销。</li>
<li><strong>服务端推送</strong>：服务器可以预测客户端可能需要的资源并提前发送，减少了延迟。</li>
<li><strong>二进制格式</strong>：HTTP&#x2F;2使用二进制而非文本格式，提高了协议解析效率和可靠性。</li>
</ul>
<blockquote>
<h4 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h4><p>基于QUIC减少延迟</p>
</blockquote>
<ul>
<li><strong>基于QUIC</strong>：HTTP&#x2F;3基于UDP之上的QUIC协议，而不是像之前的版本那样基于TCP。QUIC提供了类似TCP的功能，但是减少了握手延迟，提高了恢复速度。</li>
<li><strong>连接迁移</strong>：QUIC支持无缝连接迁移，比如当设备在网络间切换时不会断开连接。</li>
<li><strong>降低延迟</strong>：QUIC减少了往返时间（RTT），特别是在移动设备和高延迟网络环境中。</li>
<li><strong>加密</strong>：QUIC默认使用TLS加密，提供了更好的安全性。</li>
</ul>
<h3 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h3><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p>
<ul>
<li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2"></p>
<p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ul>
<li>头部压缩（HPack将请求头记录为索引号）</li>
<li>二进制格式（增加传输效率，压缩传输体积）</li>
<li>并发传输（Stream技术）</li>
</ul>
<blockquote>
<p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/v2-f849a492f395db89e1c340b5468e18a0_1440w.jpg" alt="v2-f849a492f395db89e1c340b5468e18a0_1440w"></p>
<ul>
<li>服务器主动推送资源</li>
</ul>
<p>缺点：</p>
<ol>
<li><p>TCP 以及 TCP+TLS 建立连接的延时</p>
</li>
<li><p>TCP 的队头阻塞并没有彻底解决</p>
<blockquote>
<p>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 <code>TCP </code>层队头阻塞c</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/v2-0675aa8e0177293bf5abbfb2c0fc164b_r.jpg" alt="v2-0675aa8e0177293bf5abbfb2c0fc164b_r"></p>
</li>
<li><p>多路复用导致服务器压力上升</p>
</li>
<li><p>多路复用容易 Timeout</p>
</li>
</ol>
<h3 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h3><p>HTTP3使用UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有以下 3 个特点。</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
<h2 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h2><h3 id="HTTP-缓存实现方式"><a href="#HTTP-缓存实现方式" class="headerlink" title="HTTP 缓存实现方式"></a>HTTP 缓存实现方式</h3><blockquote>
<ol>
<li><strong>强制缓存</strong></li>
</ol>
<p>多次请求数据一样就会在本地建立缓存，并设置过期时间</p>
<ol start="2">
<li><strong>协商缓存</strong></li>
</ol>
<p>一个请求已经访问过一次了，下次访问请求缓存，如果已经过期，则携带etag向服务器请求数据，比对etag是否相同，如果相同返回304，并将缓存数据返回：在这里etag类似于版本号！</p>
</blockquote>
<p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。</p>
<p>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p>
<p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<h3 id="什么是强制缓存？"><a href="#什么是强制缓存？" class="headerlink" title="什么是强制缓存？"></a>什么是强制缓存？</h3><blockquote>
<p><strong>对应的请求产生在浏览器的缓存没有过期，浏览器强制使用该缓存</strong></p>
</blockquote>
<p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p>
<p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p>
<p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<h3 id="什么是协商缓存？"><a href="#什么是协商缓存？" class="headerlink" title="什么是协商缓存？"></a>什么是协商缓存？</h3><blockquote>
<p><em>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</em></p>
<p>发现本地缓存过期了，向服务器协商是否过期缓存可以使用，如果可以使用则直接返回本地缓存的数据</p>
</blockquote>
<p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p>上图就是一个协商缓存的过程，所以<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p>
<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<p>下图是强制缓存和协商缓存的工作流程：</p>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h2 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h2><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h3><ul>
<li>http和https使用的端口分别为80,443</li>
<li>https为加密传输</li>
<li>https需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，交互信息由明文转变为密文</li>
<li><strong>校验机制</strong>：无法篡改通信内容，保证你看到的都是服务器提供的安全的信息</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，证明网站的正规</li>
</ul>
<h3 id="https是如何实现的呢？"><a href="#https是如何实现的呢？" class="headerlink" title="https是如何实现的呢？"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&vd_source=70a5c913e74574ad96afc2ae210ba3e0">https是如何实现的呢？</a></h3><blockquote>
<p>HTTPS 是如何解决上面的三个风险的？</p>
</blockquote>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<ol>
<li><strong>混合加密</strong></li>
</ol>
<blockquote>
<ol>
<li><strong>客户端</strong>发送支持的（非）加密套件列表，并传递<strong>浏览器随机数</strong>（这里的浏览器随机数是用来最后生成公钥使用的）</li>
<li><strong>服务端</strong>返回对应的加密套件，并把<strong>服务端的随机数、公钥</strong>返回给客户端</li>
<li>最后客户端生成<strong>pre-master</strong>给服务端，服务端使用私钥解密，这时两方同时具备这三个随机数，生成共同的公钥</li>
<li>共同公钥用于非对称加密！</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240329204138506.png" alt="image-20240329204138506"></p>
<ol start="2">
<li>摘要算法</li>
</ol>
<blockquote>
<p>保障数据不被篡改：</p>
<p>简单来说就是在发送内容的时候计算出原内容的Hash值，送到服务端继续计算Hash值比对，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong></p>
</blockquote>
<ol start="3">
<li><strong>数字证书</strong></li>
</ol>
<blockquote>
<p>数字证书是由内容做完Hash运算得到的<strong>Hash值，再使用私钥对其加密得到</strong>数字签名：</p>
<p>私钥是只有服务器有的，对应的公钥才能解密，确保解决了冒充风险！</p>
</blockquote>
<blockquote>
<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险</p>
</blockquote>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li><strong>无连接</strong>：只知道对端的IP和端口号就可以发送，不需要实现建立连接。(就像寄信)。</li>
<li><strong>不可靠</strong>：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。</li>
<li><strong>面向数据报</strong>： 应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。所以UDP不能够灵活的控制读写数据的次数和数量。<br>UDP存在接收缓冲区，但不存在发送缓冲区。UDP没有发送缓冲区，在调用send to时会直接将数据交给内核，由内核将数据传给网络层协议进行后续的传输动作。UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报文的顺序和发送UDP报的顺序一致，如果缓冲区满了再到达的UDP数据报就会被丢弃。</li>
</ul>
<blockquote>
<p><strong>为什么UDP不需要发送缓冲区？</strong> 因为UDP不保证可靠性，它没有重传机制，当报文丢失时，UDP不需要重新发送，而TCP不同，他必须具备发送缓冲区，当报文丢失时，TCP必须保证重新发送，用户不会管，所以必须要具备发送缓冲区。</p>
</blockquote>
<ul>
<li><strong>大小受限</strong>。UDP协议首部中有一个16位的最大长度。也就是说一个UDP能传输的数据最大长度是64K（包含UDP首部）。</li>
</ul>
<p><strong>优点：</strong>（低时延、开销小、广播通信）</p>
<ul>
<li><p>无连接，开销小</p>
</li>
<li><p>没有复杂的可靠机制，时延低</p>
<blockquote>
<p>多人在线游戏对延迟非常敏感，UDP 的低延迟特性非常适合</p>
</blockquote>
</li>
<li><p>支持一对多广播通信</p>
</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li><strong>面向连接</strong>：TCP要求建立连接（三次握手），并在数据传输完成后断开连接（四次挥手）</li>
<li><strong>可靠性</strong>：重传机制，错误检测（如果检测到错误，数据包将被丢弃，发送方会在超时后重新发送丢失的数据包）</li>
<li><strong>多路复用</strong>：TCP支持在同一连接上进行多个数据流的传输</li>
<li><strong>流量控制</strong>：TCP使用滑动窗口机制来进行流量控制，防止发送方发送数据的速度超过接收方处理的能力</li>
</ul>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><blockquote>
<ul>
<li>定义：ARP为<strong>地址解析协议（<code>Address Resolution Protocol</code>）</strong>，介于网络层和数据链路层之间用于转换，将<code>IP</code>地址转化为设备的<code>MAC</code>地址</li>
<li>特点：广播问询，单播响应</li>
<li>工作流程：当局域网内主机A需要向另外一个主机B发送IP数据包，在网络层已经知道主机B的IP，查询本机维护的IP-MAC-TTL的ARP表查看是否能直接找到主机B地址，如果找不到则会发送广播数据包，包含了需要得到对应MAC的IP地址，这时候局域网内所有的主机都会判断这个IP地址是否是自己，如果不是则丢弃，如果是则发送一个响应数据包带上自己的MAC地址，维护一张ARP表保存A的IP与Mac映射，发送到主机A，主机A也会维护一张ARP表保存B的IP与Mac映射；最后进行物理寻址</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240809090404681.png" alt="image-20240809090404681"></p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><blockquote>
<p>NAT（网络地址转换：<code>Network Address Translation</code>）允许多台设备共享一个IP地址访问互联网</p>
<p><strong>作用是将局域网IP转换为公网IP！</strong></p>
<ul>
<li>减少公网IP地址的分配</li>
<li>保障内部网络隐私和安全</li>
</ul>
</blockquote>
<h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><h3 id="什么是粘包问题"><a href="#什么是粘包问题" class="headerlink" title="什么是粘包问题"></a>什么是粘包问题</h3><blockquote>
<p>主要关于数据的定界问题</p>
</blockquote>
<ol>
<li>UPD：面向报文协议</li>
</ol>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<ol start="2">
<li>TCP：面向字节流的协议</li>
</ol>
<blockquote>
<p>[Hi] [I am student!]发送这两条消息时可能会被拆开发送，所以就需要定界</p>
</blockquote>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p>
<h3 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h3><h4 id="固定长度的消息"><a href="#固定长度的消息" class="headerlink" title="固定长度的消息"></a>固定长度的消息</h4><p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p>但是这种方式灵活性不高，实际中很少用。</p>
<h4 id="特殊字符作为边界"><a href="#特殊字符作为边界" class="headerlink" title="特殊字符作为边界"></a>特殊字符作为边界</h4><p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/a49a6bb8cd38ae1738d9c00aec68b444.png" alt="a49a6bb8cd38ae1738d9c00aec68b444"></p>
<p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<h4 id="自定义消息结构"><a href="#自定义消息结构" class="headerlink" title="自定义消息结构"></a>自定义消息结构</h4><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，<strong>而且包头里有一个字段来说明紧随其后的数据有多大</strong>。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="type">u_int32_t</span> message_length; </span><br><span class="line">    <span class="type">char</span> message_data[]; </span><br><span class="line">&#125; message;</span><br></pre></td></tr></table></figure>

<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对于定长的数据包，保证每次都按固定的大小读取即可；</li>
<li>对于变长的包，可在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置；</li>
<li>对于变长的包，还可以在包和包之间使用明确的分隔符（应用层协议，是我们自己写的，只要保证分隔符不和正文冲突即可）</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="国内访问国外网站这个过程发生了什么？"><a href="#国内访问国外网站这个过程发生了什么？" class="headerlink" title="国内访问国外网站这个过程发生了什么？"></a>国内访问国外网站这个过程发生了什么？</h3><ol>
<li>发起请求：<ul>
<li>用户在国内的电脑或移动设备上输入网址或发起访问请求。</li>
</ul>
</li>
<li>域名解析（DNS查询）：<ul>
<li>用户的设备会向配置的DNS服务器发送一个查询包，询问该网址对应的IP地址。</li>
<li>DNS服务器会返回对应的IP地址给用户的设备。</li>
</ul>
</li>
<li>数据包传输至ISP：<ul>
<li>用户的设备通过网络接入设备（如路由器）将请求数据包发送到本地网络提供商（ISP）。</li>
</ul>
</li>
<li>转发至国际出口节点：<ul>
<li>ISP将请求数据包转发到国家本地的边界网关（也称为国际出口节点），这是连接国内网络和国际互联网的关键节点。</li>
</ul>
</li>
<li>选择最佳国际出口通道：(VPN)<ul>
<li>边界网关会根据目标国际IP地址来选择最佳的国际出口通道或运营商，并将请求数据包发送到该出口通道。</li>
</ul>
</li>
<li>数据包进入国际互联网：<ul>
<li>请求数据包从国内网络通过国际出口通道进入国际互联网，然后经过一系列的路由器和网络节点进行传输。</li>
</ul>
</li>
<li>到达目标国家：<ul>
<li>当请求数据包到达目标国家之后，它会经过该国家的边界网关，然后进入目标国家的本地网络。</li>
</ul>
</li>
<li>目标服务器响应：<ul>
<li>目标国家的本地ISP会将请求数据包传送给目标外网服务器。</li>
<li>目标外网服务器接收到请求数据包后，会将响应数据包通过相同的路径返回给用户的设备。</li>
</ul>
</li>
<li>数据包返回用户设备：<ul>
<li>响应数据包沿着相同的路径通过边界网关、国际出口通道和ISP传回至用户的设备。</li>
</ul>
</li>
<li>解析并显示内容：<ul>
<li>用户的设备接收到响应数据包后，解析其中的内容。如果是网页，设备会渲染并显示给用户；如果是邮件，则会在客户端上显示。</li>
</ul>
</li>
</ol>
<p>![【干货】你还不知道路由器工作原理吗，99%的人都看得懂 - 图片](..&#x2F;image&#x2F;【干货】你还不知道路由器工作原理吗，99%的人都看得懂 - 图片.png)</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ul>
<li>TCP：面向连接、可靠（重传机制）、基于字节流</li>
<li>UDP：无连接、不可靠、大小受限（64kb）、基于数据报</li>
</ul>
<blockquote>
<p>UDP不存在发送缓冲区注定他没有重传机制，但是他有接收缓冲区，这个缓冲区不保障数据的顺序、超过大小的数据也会被丢弃</p>
</blockquote>
<h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>分布式拒绝服务攻击，与Dos区别在于DDOS采用的是分布式攻击，而DOS单一机器的攻击</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20241130170352104.png" alt="image-20241130170352104"></p>
<p><strong>攻击方法：</strong></p>
<ul>
<li><strong>TCP洪水：</strong>将多台服务器向同一台服务器同时发送TCP连接请求，但是不进行最后的第三次握手，导致服务器接收到大量的资源进入半连接的状态</li>
<li><strong>高频的Http请求</strong>：导致每个请求都要访问数据库，这种费事的IO操作在高频的执行下也会将服务器弄垮</li>
</ul>
<p><strong>解决策略：</strong></p>
<ul>
<li>使用缓存</li>
<li>设置访问黑名单</li>
<li>微服务架构，负载均衡</li>
</ul>
<p><strong>拓展：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15vS3YpEt8/?spm_id_from=333.337.search-card.all.click&vd_source=70a5c913e74574ad96afc2ae210ba3e0">UDP-NTP实现DDOS攻击</a></p>
<ul>
<li>UDP找出网络中支持NTP的主机</li>
<li>通过NTP对流量进行增大传输</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">FANSEA</div><div class="post-copyright__author_desc">目标明确，只管去做</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/')">计算机网络</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=计算机网络&amp;url=https://fansea0.github.io/2023/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fansea0.github.io" target="_blank">FANSEA</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机基础<span class="tagsPageCount">4</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/fansea.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/20/java%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java进阶学习路线</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/20/Redis%E9%AB%98%E7%BA%A7/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis高级</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/10/16/Linux%E9%87%8D%E8%A6%81%E6%8C%87%E4%BB%A4/" title="linux常用指令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-16</div><div class="title">linux常用指令</div></div></a></div><div><a href="/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-12</div><div class="title">操作系统</div></div></a></div><div><a href="/2024/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="计算机底层原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-08</div><div class="title">计算机底层原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI7%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">OSI7层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">TCP&#x2F;IP网络模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E7%BD%91%E5%85%B3"><span class="toc-number">1.2.</span> <span class="toc-text">交换机和网关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.</span> <span class="toc-text">TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0-%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">快重传 快恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">1.3.5.</span> <span class="toc-text">可靠传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">1.4.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">HTTP字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E4%B8%8E-POST"><span class="toc-number">1.4.2.</span> <span class="toc-text">GET 与 POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">HTTP版本对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-0"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">HTTP 1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">HTTP 1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2-0"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">HTTP 2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3-0"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">HTTP 3.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-0%E5%92%8CHTTP1-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">HTTP1.0和HTTP1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2"><span class="toc-number">1.4.5.</span> <span class="toc-text">HTTP2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.4.6.</span> <span class="toc-text">HTTP&#x2F;3 做了哪些优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">1.5.</span> <span class="toc-text">HTTP 缓存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">HTTP 缓存实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">什么是强制缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">什么是协商缓存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E4%B8%8Ehttps"><span class="toc-number">1.6.</span> <span class="toc-text">http与https</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">1.6.1.</span> <span class="toc-text">不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">https是如何实现的呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.7.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">1.7.1.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">1.7.2.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP"><span class="toc-number">1.7.3.</span> <span class="toc-text">ARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT"><span class="toc-number">1.7.4.</span> <span class="toc-text">NAT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">粘包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是粘包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85"><span class="toc-number">1.8.2.</span> <span class="toc-text">如何解决粘包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">固定长度的消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E8%BE%B9%E7%95%8C"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">特殊字符作为边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">自定义消息结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">1.9.</span> <span class="toc-text">思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E5%9B%BD%E5%A4%96%E7%BD%91%E7%AB%99%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">国内访问国外网站这个过程发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.2.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDOS%E6%94%BB%E5%87%BB"><span class="toc-number">1.9.3.</span> <span class="toc-text">DDOS攻击</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/26/RAG%E5%AE%A2%E6%9C%8D%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AE%BE%E8%AE%A1/" title="无题">无题</a><time datetime="2025-04-26T02:59:57.165Z" title="发表于 2025-04-26 10:59:57">2025-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/20/%E7%94%B5%E5%95%86%E9%A2%86%E5%9F%9FRAG%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AE%BE%E8%AE%A1/" title="电商领域RAG客服聊天机器人设计">电商领域RAG客服聊天机器人设计</a><time datetime="2025-04-20T09:47:57.000Z" title="发表于 2025-04-20 17:47:57">2025-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/AI%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AE%BE%E8%AE%A1/" title="AI聊天机器人设计">AI聊天机器人设计</a><time datetime="2025-04-06T06:28:45.000Z" title="发表于 2025-04-06 14:28:45">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/03/AI-Learning/" title="AI-Learning">AI-Learning</a><time datetime="2025-04-03T09:04:03.000Z" title="发表于 2025-04-03 17:04:03">2025-04-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/30/Docker%E5%AD%A6%E4%B9%A0/" title="Docker学习">Docker学习</a><time datetime="2025-03-30T06:58:02.000Z" title="发表于 2025-03-30 14:58:02">2025-03-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="FANSEA" target="_blank">FANSEA</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">99</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/MQ/" style="font-size: 0.88rem;">MQ<sup>1</sup></a><a href="/tags/NoSQL/" style="font-size: 0.88rem;">NoSQL<sup>2</sup></a><a href="/tags/ROS/" style="font-size: 0.88rem;">ROS<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>8</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E5%88%9B%E4%B8%9A/" style="font-size: 0.88rem;">创业<sup>1</sup></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">微服务<sup>4</sup></a><a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 0.88rem;">思考<sup>10</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 0.88rem;">技术<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/" style="font-size: 0.88rem;">技术漫谈<sup>21</sup></a><a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 0.88rem;">摄影<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>6</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>7</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>4</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A7%E5%88%B6/" style="font-size: 0.88rem;">计算机控制<sup>1</sup></a><a href="/tags/%E8%BD%A6%E8%BD%A6/" style="font-size: 0.88rem;">车车<sup>1</sup></a><a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 0.88rem;">金融<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>11</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 FANSEA 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>