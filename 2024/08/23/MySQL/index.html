<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>MySQL深入浅出 | FANSEA</title><meta name="keywords" content="数据库"><meta name="author" content="FANSEA"><meta name="copyright" content="FANSEA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="MySQL深入浅出"><meta name="application-name" content="MySQL深入浅出"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="MySQL深入浅出"><meta property="og:url" content="https://fansea0.github.io/2024/08/23/MySQL/index.html"><meta property="og:site_name" content="FANSEA"><meta property="og:description" content="MySQL深入浅出 MySQL其实没那么神秘，也就是一个应用程序，他像其他程序一样共用电脑的CPU内存以及硬盘，但是他主要的作用就是提供了一套很适用于软件数据的数据存储结构存储方案，以及完善的增删改查机制，和一些高级功能能适配很多场景的开发   数据库设计的三大范式第一范式：原子性存储的数据应该具有"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://fansea0.github.io/fansea.png"><meta property="article:author" content="FANSEA"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://fansea0.github.io/fansea.png"><meta name="description" content="MySQL深入浅出 MySQL其实没那么神秘，也就是一个应用程序，他像其他程序一样共用电脑的CPU内存以及硬盘，但是他主要的作用就是提供了一套很适用于软件数据的数据存储结构存储方案，以及完善的增删改查机制，和一些高级功能能适配很多场景的开发   数据库设计的三大范式第一范式：原子性存储的数据应该具有"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://fansea0.github.io/2024/08/23/MySQL/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: FANSEA","link":"链接: ","source":"来源: FANSEA","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'FANSEA',
  title: 'MySQL深入浅出',
  postAI: '',
  pageFillDescription: 'MySQL深入浅出, 数据库设计的三大范式, 第一范式：原子性, 第二范式：唯一性, 第三范式：独立性, 修改, MySQL知识小站, 设计库模板, 二级索引, （非）聚簇索引, 覆盖索引, 开篇第一问, 设计索引, 打印昨天的数据, 根据订单类型计算金额总和, 使用多线程, 追问：怎么计算金额总和, 应用层实现, 索引查询 ❀, 创建索引, 使用索引进行查询, 注意事项, 联合索引, MySQL 执行流程是怎样的？, 第四步：执行 SQL, 预处理器, 优化器, 执行器, 主键索引查询, 全表扫描, 索引下推, 总结, SQL知识加油站, Having与Where的区别, 函数, 查询两个日期之间行, 关联查询 - inner join, 关联查询 - cross join, 关联查询 - outer join（left x2F right）, Mysql数据是怎么存储的, 行（row）, 页（page）, 区（extent）, 段（segment）, 索引, B+Tree vs B Tree, BufferPool, Log文件, 全文索引, 读懂explain语句, 如何创建索引, 创建普通索引, 创建联合索引, 对函数创建索引, 索引篇, 普通索引可以为NULL吗, 说说索引有哪些？, innoDB中页内查询, B+ 树是如何进行查询的？, 总结, 索引失效情况！, MySQL 使用 like %x索引一定会失效吗？, COUNT()函数性能比较, COUNT(字段), COUNT(主键), COUNT(1), COUNT(*), 事务篇, 事务的几大特性, 事务隔离级有哪些, MySQL如何解决可重复读, MVCC实现读提交和可重复读, 可重复读（快照读）如何解决幻读, 当前读如何解决幻读, 锁机制, 全局锁, 表级锁, 表锁, 元数据锁（MDL）, 意向锁, AUTO-INC 锁, 行级锁, Record Lock, Gap Lock, Next-key Lock, 插入意向锁, MySQL是如何加行级锁的, 唯一索引等值查询, 唯一索引范围查询, update没加索引导致的问题, 如何会发生死锁, 如何预防死锁, BufferPool, 缓存页, 控制块, 如何管理空闲页, 如何提高命中率, 日志篇, undolog, redolog, undolog和redolog有什么区别？, redo log 和 binlog 有什么区别？, binlog主从复制, 思考题, 数据库三大范式, innoDB对比MyISAM, 简单说一说drop、delete与truncate的区别, 大表优化方案（数据量大）, SQL优化, 分布式唯一ID如何解决, NoSQL与关系型数据库区别, PostgreSQL对比MySQL, 介绍ORM框架深入浅出其实没那么神秘也就是一个应用程序他像其他程序一样共用电脑的内存以及硬盘但是他主要的作用就是提供了一套很适用于软件数据的数据存储结构存储方案以及完善的增删改查机制和一些高级功能能适配很多场景的开发数据库设计的三大范式第一范式原子性存储的数据应该具有不可再分性第二范式唯一性非主键字段的值必须完全依赖主键一般这种情况需要做分表下图为表但是包含了课程的信息非主键字段课表信息的字段并未全依赖主键字段这是冗余的应该拆分出来第三范式独立性消除传递依赖非主键值不依赖于另一个非主键值非主键字段之间产生依赖修改知识小站中的聚簇索引非聚簇索引联合索引和唯一索引唯一索引是聚簇索引吗博客设计库模板在这个数据类型中表示数字的总位数包括小数点前的部分和小数点后的部分表示小数点后的位数二级索引区别于主键索引单个列的索引比如也称为普通索引这种索引允许同一索引列中存在重复的值也可以为在电商平台的用户行为数据分析中可以根据用户和商品类别建立二级索引以便快速查询某个用户在某个商品类别下的行为数据非聚簇索引聚簇索引也叫主键索引是将索引和数据放在一起聚簇索引的的叶子节点存放的是实际数据所有完整的用户记录都存放在主键索引的的叶子节点里找到索引也就找到了数据一般情况下主键会默认创建聚簇索引且一张表只允许存在一个聚簇索引非聚簇索引是指二级索引也叫辅助索引通过非聚簇索引可以查到记录对应的主键值再使用主键的值通过聚簇索引找到要查找的数据中在聚簇索引之上创建的索引称之为辅助索引辅助索引访问数据总是需要二次查找非聚簇索引都是辅助索引辅助索引叶子节点存储的不再是行的物理位置而是主键值覆盖索引这种在二级索引的就能查询到结果的过程就叫作覆盖索引也就是只需要查一个就能找到数据意思是说仅仅根据索引建立的树就能查到数据无需进行回表操作叫覆盖索引开篇第一问一个场景题一个单表列是唯一订单类型订单时间金额一天有三千万条数据现在要将昨天的数据打印出来怎么设计索引具体怎么操作然后现在要根据订单类型计算每种订单类型的金额总和怎么操作提示根据时间分提交多线程随后追问怎么计算金额总和对于给定的场景我们需要设计一个有效的索引策略以便能够快速检索昨天的数据并且还要计算每种订单类型的金额总和设计索引考虑到查询需求主要是基于订单时间假设为字段和订单类型假设为字段我们可以设计一个复合索引来优化查询这个索引首先按照排序对于相同的时间再按照排序这样设计有几个好处范围查询优化当我们需要查询某个时间段内的数据时例如昨天的数据数据库可以利用索引快速定位到这个时间范围覆盖索引如果查询只需要和字段那么可以直接使用索引来满足查询而无需回表查找排序优化如果查询需要对结果进行排序并且排序顺序与索引顺序一致那么排序操作将非常高效打印昨天的数据要打印昨天的数据我们可以使用以下语句函数返回当前日期不包含时间部分从当前日期中减去一天得到昨天的日期这里使用了语句来指定时间范围从昨天的午夜开始到今天的午夜前一秒结束确保字段是日期时间类型如或以便能够正确地进行比较根据订单类型计算金额总和要计算每种订单类型的金额总和我们可以使用语句和聚合函数这个查询会返回每种订单类型及其对应的金额总和注意这里我们同样使用了之前定义的时间范围来限制结果集只包含昨天的数据使用多线程如果数据量非常大并且服务器有足够的资源可以考虑使用多线程来并行处理数据然而对于查询来说通常不需要显式地创建多线程来处理因为服务器内部已经为查询优化和执行做了大量的工作如果确实需要利用多线程来提高性能那么应该考虑在应用层实现比如将时间范围划分成多个子区间每个线程处理一个子区间的数据追问怎么计算金额总和在上面的语句中我们已经展示了如何计算金额总和通过我们可以得到每种订单类型的总金额这个操作是在查询中直接完成的会扫描符合条件的行并对每一行的字段进行求和然后按照进行分组如果数据量非常大计算过程可能会比较慢这时可以考虑以下几个优化策略确保索引有效如上所述确保和字段上有合适的索引以加速数据的检索和分组硬件和配置优化根据服务器的硬件配置如内存磁盘等调整的配置参数以优化查询性能分区表如果表非常大并且经常需要按时间范围查询数据可以考虑使用的分区表功能通过将表按照时间范围进行分区可以提高查询性能定期汇总如果订单数据的变更不频繁可以考虑定期如每天或每小时计算并存储订单类型的金额总和这样就不需要实时计算而是直接查询预先计算好的结果记住在实际应用中最佳的做法通常取决于具体的数据量查询频率硬件资源以及业务需求因此在实施任何优化策略之前最好先进行性能测试和分析以确定最有效的方案应用层实现在应用层使用多线程优化数据检索和计算操作通常涉及将任务划分为多个子任务并并行执行这些子任务以加快整体处理速度对于数据库查询和计算订单类型金额总和的场景可以通过以下步骤实现多线程优化任务分解首先确定哪些部分的任务可以并行执行在数据库查询的场景中如果查询的数据量非常大并且数据库服务器能够支持并发查询那么可以将查询拆分成多个子查询每个子查询负责检索一部分数据对于计算订单类型金额总和的任务如果每种订单类型的计算是独立的那么也可以将这些计算任务分配给不同的线程并行执行创建线程或线程池根据需要创建足够数量的线程或线程池来执行子任务使用线程池可以避免频繁地创建和销毁线程从而提高性能在中可以使用和来创建和管理线程池分配任务将子任务分配给线程池中的线程执行这通常涉及到将查询条件或计算参数传递给线程执行数据库查询如果查询任务被拆分成多个子查询每个线程将执行其分配的子查询并获取结果集确保数据库连接是线程安全的或者为每个线程创建独立的数据库连接计算金额总和对于计算订单类型金额总和的任务每个线程将处理其分配的订单类型并计算相应的金额总和可以使用线程安全的集合如来存储每个订单类型的计算结果以便后续合并合并结果当所有线程完成其任务后需要合并它们的结果对于数据库查询这通常意味着将各个子查询的结果集合并成一个完整的结果集对于金额总和的计算需要将各个线程计算的结果相加得到每种订单类型的总金额关闭线程池一旦所有任务完成并且结果已经合并关闭线程池以释放资源以下是一个简化的代码示例展示了如何使用线程池并行执行数据库查询任务假设有一个类用于执行数据库查询执行数据库查询并返回结果返回订单列表假设类代表订单包含订单类型和金额等字段其他字段和构造函数等创建一个固定大小的线程池假设我们按时间范围拆分查询任务昨天的开始时间昨天的结束时间或今天的开始时间假设我们将查询拆分成个任务好好学学别人如何多线程处理带返回值的任务等待所有任务完成并合并结果获取每个任务的结果并添加到总列表中方法关闭线程池现在可以对进行处理比如计算每种订单类型的金额总和等处理计算每种订单类型的金额总和如果订单类型已经存在于中则累加金额否则初始化金额为当前订单的金额这一步方法恰到好处查询是否存在键存在返回值不存在初始化值为打印每种订单类型的金额总和的遍历方法索引查询当你说根据自己创建索引查询我理解为你想了解如何根据自己的需求在数据库中创建索引并如何使用这些索引进行查询以下是一个简单的例子说明如何在关系型数据库中以为例创建索引并使用它进行查询创建索引假设我们有一个名为的表其中包含和三个字段如果我们经常根据字段进行查询那么为了提高查询效率我们可以为字段创建一个索引使用语句创建索引这条命令会在表的字段上创建一个名为的索引使用索引进行查询一旦索引创建成功你就可以在查询中使用它来提高性能例如如果你想根据字段查找用户你可以这样写查询优化器会自动决定是否使用索引来加速这个查询如果它认为使用索引比全表扫描更快它就会使用索引注意事项选择性索引的选择性越高其效果通常越好选择性是指不重复的索引值与总记录数的比率例如一个只有和两个值的字段可能不是一个好的索引候选因为它的选择性很低维护成本每次插入更新或删除记录时索引都需要被更新因此过多的索引会增加写操作的开销覆盖索引如果一个查询只需要访问索引中的信息而不需要回表访问数据行那么这个查询就被称为覆盖索引查询这种查询通常非常快避免过度索引只为那些经常出现在子句条件或子句中的列创建索引覆盖索引索引就是你需要查询的列话就不需要在磁盘加载其他数据块了直接在索引库找到数据返回减少次数效率非常高是指一个索引包含了查询所需的所有列而无需访问表的实际数据页当数据库系统执行查询时通常需要从磁盘中读取数据页到内存中才能进行处理而如果使用了覆盖索引由于索引已经包含了查询所需的所有列的值数据库系统可以直接通过索引来获取这些值而不需要额外地读取数据页这样可以减少磁盘的次数和数据在内存中的占用提高查询的效率最后为了确定你的索引是否有效地提高了查询性能你可以使用数据库的查询执行计划工具如的语句来查看查询是如何使用索引的联合索引当数据库表中同时建立索引和二级索引数据库索引库会发生什么变化当然是对字段生成一个索引库如果说叶子节点包含完整的用户记录索引库多了将会占用磁盘很大空间那我们该怎么办呢联想一下本身建立了索引并叶子节点携带所有数据查询是不是非常快那么是不思路豁然开朗了我们就可以选择重新建立索引库这次索引库叶子节点只包含和数据量大大降低根据所查到的再去索引库查询最终数据因为并不是一个主键索引所以可能会有多个对应结果这样就需要回表知道查询到对应的数据为止所以谈论这么多联合索引又是什么呢相当于同时创建的两个二级索引但是这个二级索引遵循最左原则同样的是根据两个索引加上主键索引创建索引库即叶子节点不携带数据这样的话会首先根据左边的索引先排序所以在叶子节点中会出现相同的节点这时才会根据排序所以说相同值的节点下可能会保存不同的所以如果直接搜索索引是乱序的就不会起作用执行流程是怎样的先来一个上帝视角图下面就是执行一条查询语句的流程也从图中可以看到内部架构里的各个功能模块可以看到的架构共分为两层层和存储引擎层层负责建立连接分析和执行大多数的核心功能模块都在这实现主要包括连接器查询缓存解析器预处理器优化器执行器等另外所有的内置函数如日期时间数学和加密函数等和所有跨存储引擎的功能如存储过程触发器视图等都在层实现存储引擎层负责数据的存储和提取支持等多个存储引擎不同的存储引擎共用一个层现在最常用的存储引擎是从版本开始成为了的默认存储引擎我们常说的索引数据结构就是由存储引擎层实现的不同的存储引擎支持的索引类型也不相同比如支持索引类型是树且是默认使用也就是说在数据表中创建的主键索引和二级索引默认使用的是树索引第四步执行经过解析器后接着就要进入执行查询语句的流程了每条查询语句流程主要可以分为下面这三个阶段阶段也就是预处理阶段阶段也就是优化阶段阶段也就是执行阶段预处理器查询表是否存在优化器小鱼同学优化器会在多种索引中使用效率最高的索引很显然这条查询语句是覆盖索引直接在二级索引就能查找到结果因为二级索引的树的叶子节点的数据存储的是主键值就没必要在主键索引查找了因为查询主键索引的树的成本会比查询二级索引的的成本大优化器基于查询成本的考虑会选择查询代价小的普通索引执行器作为存储引擎会调用方法来根据不同策略来搜素当搜索条件包含主键索引时方法逐步查询存储引擎通过主键索引的树结构定位到的第一条记录将数据返回给客户端当不包含索引时方法循环查询查询到匹配的将一个一个返回到客户端经历完优化器后就确定了执行方案接下来就真正开始执行语句了这个工作是由执行器完成的在执行的过程中执行器就会和存储引擎交互了交互是以记录为单位的执行器和存储引擎的交互过程主键索引查询全表扫描索引下推主键索引查询以本文开头查询语句为例看看执行器是怎么工作的这条查询语句的查询条件用到了主键索引而且是等值查询同时主键是唯一不会有相同的记录所以优化器决定选用访问类型为进行查询也就是使用主键索引查询一条记录那么执行器与存储引擎的执行流程是这样的执行器第一次查询会调用函数指针指向的函数因为优化器选择的访问类型为这个函数指针被指向为引擎索引查询的接口把条件交给存储引擎让存储引擎定位符合条件的第一条记录存储引擎通过主键索引的树结构定位到的第一条记录如果记录是不存在的就会向执行器上报记录找不到的错误然后查询结束如果记录是存在的就会将记录返回给执行器执行器从存储引擎读到记录后接着判断记录是否符合查询条件如果符合则发送给客户端如果不符合则跳过该记录执行器查询的过程是一个循环所以还会再查一次但是这次因为不是第一次查询了所以会调用函数指针指向的函数因为优化器选择的访问类型为这个函数指针被指向为一个永远返回的函数所以当调用该函数的时候执行器就退出循环也就是结束查询了至此这个语句就执行完成了全表扫描举个全表扫描的例子这条查询语句的查询条件没有用到索引所以优化器决定选用访问类型为进行查询也就是全表扫描的方式查询那么这时执行器与存储引擎的执行流程是这样的执行器第一次查询会调用函数指针指向的函数因为优化器选择的访问类型为这个函数指针被指向为引擎全扫描的接口让存储引擎读取表中的第一条记录执行器会判断读到的这条记录的是不是如果不是则跳过如果是则将记录发给客户的是的没错层每从存储引擎读到一条记录就会发送给客户端之所以客户端显示的时候是直接显示所有记录的是因为客户端是等查询语句查询完成后才会显示出所有的记录执行器查询的过程是一个循环所以还会再查一次会调用函数指针指向的函数因为优化器选择的访问类型为函数指针指向的还是引擎全扫描的接口所以接着向存储引擎层要求继续读刚才那条记录的下一条记录存储引擎把下一条记录取出后就将其返回给执行器层执行器继续判断条件不符合查询条件即跳过该记录否则发送到客户端一直重复上述过程直到存储引擎把表中的所有记录读完然后向执行器层返回了读取完毕的信息执行器收到存储引擎报告的查询完毕的信息退出循环停止查询索引下推使用在联合索引索引下推能够减少二级索引在查询时的回表操作提高查询的效率因为它将层部分负责的事情交给存储引擎层去处理了举一个具体的例子方便大家理解这里一张用户表如下我对和字段建立了联合索引现在有下面这条查询语句联合索引当遇到范围查询就会停止匹配也就是字段能用到联合索引但是字段则无法利用到索引具体原因这里可以看这篇索引常见面试题那么不使用索引下推之前的版本时执行器与存储引擎的执行流程是这样的层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录也就是定位到的第一条记录存储引擎根据二级索引的树快速定位到这条记录后获取主键值然后进行回表操作将完整的记录返回给层层在判断该记录的是否等于如果成立则将其发送给客户端否则跳过该记录接着继续向存储引擎索要下一条记录存储引擎在二级索引定位到记录后获取主键值然后回表操作将完整的记录返回给层如此往复直到存储引擎把表中的所有记录读完可以看到没有索引下推的时候每查询到一条二级索引记录都要进行回表操作然后将记录返回给接着再判断该记录的是否等于而使用索引下推后判断记录的是否等于的工作交给了存储引擎层过程如下层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录也就是定位到的第一条记录存储引擎定位到二级索引后先不执行回表操作而是先判断一下该索引中包含的列列的条件是否等于是否成立如果条件不成立则直接跳过该二级索引如果成立则执行回表操作将完成记录返回给层层在判断其他的查询条件本次查询没有其他条件是否成立如果成立则将其发送给客户端否则跳过该记录然后向存储引擎索要下一条记录如此往复直到存储引擎把表中的所有记录读完可以看到使用了索引下推后虽然列无法使用到联合索引但是因为它包含在联合索引里所以直接在存储引擎过滤出满足的记录后才去执行回表操作获取整个记录相比于没有使用索引下推节省了很多回表操作当你发现执行计划里的部分显示了说明使用了索引下推总结执行一条查询语句期间发生了什么连接器建立连接管理连接校验用户身份查询缓存查询语句如果命中查询缓存则直接返回否则继续往下执行已删除该模块解析通过解析器对查询语句进行词法分析语法分析然后构建语法树方便后续模块读取表名字段语句类型执行执行共有三个阶段预处理阶段检查表或字段是否存在将中的符号扩展为表上的所有列优化阶段基于查询成本的考虑选择查询成本最小的执行计划执行阶段根据执行计划执行查询语句从存储引擎读取记录返回给客户端知识加油站查询字段不为的数据作用相反模糊查询姓李的人代表任意多少字符代表一个字符李多条件查询李去重查询多条件去重就会根据组合来去重排序规则分页截取数据多条件筛选条件干什么用于查询赋值给自设字段老同学年轻小同学时间函数当前日期当前日期和时间时间字符串处理将英文大小写热聚合函数分组聚合分组聚合多条件分组分组之后判断不同于是分组之前判断关联查询不用带之后的表内容将会以笛卡尔积返回关联查询只返回两方的交集关联查询返回表的所有值表的匹配值与的区别用于分组后对数据的过滤用于分组之前的数据过滤之母免费自学网站程序员鱼皮请在此处输入函数根据的表单数量来计算如果有分组语句就按分组计算为列统计最近五年的每一年的总数按年降序统计每一年的总数统计最近五年的每一年的总数按年降序查询两个日期之间行要查询两个日期之间的数据你可以使用的操作符配合日期字段来实现假设你有一个名为的表其中有一个日期字段你可以使用以下查询来获取两个日期之间的数据在上面的查询中你需要将替换为你的实际表名替换为你的实际日期字段名同时将和替换为你要查询的起始日期和结束日期请确保你提供的日期格式与数据库中存储的日期格式相匹配通常日期格式可以是或数据库特定的其他格式另外如果你想要包含起始日期和结束日期在内的数据上面的查询已经足够了如果你只想包含起始日期之前的数据而不包括结束日期你可以稍微修改查询如下在这个查询中我们使用操作符来包含起始日期并使用操作符来排除结束日期这样你将获得从起始日期开始到结束日期之前的数据关联查询在中是一种常见的关联查询方式它根据两个表之间的关联条件将满足条件的行组合在一起注意只返回两个表中满足关联条件的交集部分即在两个表中都存在的匹配行关联查询在中关联查询是一种用于联合多个数据表中的数据的查询方式其中是一种简单的关联查询不需要任何条件来匹配行它直接将左表的每一行与右表的每一行进行组合返回的结果是两个表的笛卡尔积关联查询的优先级低于先连表查出合适的数据再用过滤在中是一种关联查询方式它根据指定的关联条件将两个表中满足条件的行组合在一起并包含没有匹配的行在中包括和两种类型它们分别表示查询左表和右表的所有行即使没有被匹配再加上满足条件的交集部分多表查询场景根据查询到用户的权限信息数据是怎么存储的行每一条数据都是按行保存的页的数据是按页为单位来读写的当需要读一条记录的时候并不是将这个行记录从磁盘读出来而是以页为单位将其整体读入内存页类型数据页索引页日志页溢出页区树每个节点以区划分在表中数据量大的时候为某个索引分配空间的时候就不再按照页为单位分配了而是按照区为单位分配每个区的大小为对于的页来说连续的个页会被划为一个区这样就使得链表中相邻的页的物理位置也相邻就能使用顺序了段表空间是由各个段组成的段是由多个区组成的段一般分为数据段索引段和回滚段等索引段存放树的非叶子节点的区的集合数据段存放树的叶子节点的区的集合回滚段存放的是回滚数据的区的集合之前讲事务隔离的时候就介绍到了利用了回滚段实现了多版本查询数据索引只在叶子节点存储数据而树的非叶子节点也要存储数据所以的单个节点的数据量更小在相同的磁盘次数下就能查询更多的节点另外叶子节点采用的是双链表连接适合中常见的基于范围的顺序查找而树无法做到这一点的叶子节点采用双链表连接的原因主要有以下几点有序性树的叶子节点中存储的是数据而不是关键字因此叶子节点之间必须有一种有序的方式来存储数据双链表作为一种有序的数据结构正好满足了这一要求通过双链表连接叶子节点可以按照顺序进行排列使得数据的存储和检索更加有序和高效范围查询友好树中每一层的节点与相邻节点有指针相互连接双向这样在类似于的范围查询中提高查询速率稳定性树的内节点不存储对应的只有叶子节点存储了完整的数据信息这样的设计使得树在查询数据时每次都必须到达叶子节点才能获取数据虽然这看似增加了查询的复杂度但实际上却提高了查询的稳定性因为无论查询哪个数据查询路径的长度都是相同的即树的高度不会出现因为数据在非叶子节点而导致查询路径长度不同的情况空间利用率树的中间节点不存指针这样同样大小的磁盘页可以容纳更多的节点元素使得树的高度相对较小在数据量相同的情况下树比树更加矮胖查找起来就更快综上所述的叶子节点采用双链表连接主要是因为双链表具有有序性范围查询友好稳定性高和空间利用率好等特点这些特点使得树在数据库索引等应用场景中具有优越的性能文件全文索引只能在文本类型类型字段上创建全文索引字段长度比较大时如果创建普通索引在进行模糊查询时效率比较低这时可以创建全文索引和中都可以使用全文索引读懂语句这是选择列表的编号数值为表示这是一个单一的操作没有子查询或联合查询等复杂结构显示了查询的类型表示这是一个简单的语句没有子查询或显示所查询的表名在这里是表这一列显示了访问类型它描述了如何访问数据表示使用主键或唯一索引查找单行记录列出可能使用的索引这里的表示可能使用主键索引来优化查询显示实际使用的索引这里的意味着确实使用了主键索引显示了使用的索引长度以字节为单位这里的可能意味着主键是一个整型字段显示了使用哪个字段或常量来查找行指的是使用常量值进行查找估计需要检查的行数这里的表明预计只需要检查一行数据这个百分比表示经过子句过滤后剩余的行数比例这里的表示没有应用额外的过滤条件或者说过滤条件已经被索引覆盖综合以上信息这个输出表明计划使用表的主键索引来查找一个确定的行由于类型是可以推断查询中包含了一个等于某常量值的主键条件使得能够直接定位到该行而无需扫描整个表这通常是一个非常高效的查询策略如何创建索引创建普通索引为表名为字段创建联合索引为表名为字段对函数创建索引索引篇普通索引可以为吗可以作为特殊值处理不会聚集在一起并且不会影响唯一性不能用等号搜寻在数据库中普通索引也称为非唯一索引或树索引是可以包含空值的一个字段如果允许值并且在其上创建了索引那么这个索引将能够存储和检索值但是有一些重要的点需要注意如果一个索引字段允许值那么值会被当作是独立于所有其他值的特殊值来处理这意味着即使有多个记录的索引字段为它们也会被视为不同的值而不会被聚集在一起一个索引字段中值的数量不会影响索引的唯一性即使在一个唯一索引中多个值也不会引发唯一性冲突因为数据库系统将视为不可比较的值在进行查询时如果使用或来查找记录索引将非常高效但如果使用等号来查找值例如这是无效的语法因为不能用等号来比较说说索引有哪些按数据结构分类索引索引索引按物理存储分类聚簇索引主键索引二级索引辅助索引按字段特性分类主键索引唯一索引普通索引前缀索引按字段个数分类单列索引联合索引中页内查询总体根据以页为单位建立索引库读写也是以页为单位的在页的内部包含重要的两个部分页目录行记录页目录将行记录分组记录了索引以及每组主键最大值用于二分查找快速定位数据而在行记录中是以主键大小为顺序连接的链表时间复杂度为为了防止每组链表数目过大避免产生过多的低效查询规定每个组不高于行数据以增加适用二分快速查找的页目录索引来尽可能提高页内查询速率树是如何进行查询的树非叶子节点是以页为单位存储的页内包含的是按照主键大小排序好的当查询某个数据将会从根节点根据索引开始搜索在页内使用二分法查找索引判断搜索的索引的大小在两个索引行之间就定位最小索引对应的下个索引页最后定位到叶子节点中使用二分法快速定位记录所在的分组槽号最后在分组内采取遍历的方式找到数据总结的数据是按数据页为单位来读写的默认数据页大小为每个数据页之间通过双向链表的形式组织起来物理上不连续但是逻辑上连续数据页内包含用户记录每个记录之间用单向链表的方式组织起来为了加快在数据页内高效查询记录设计了一个页目录页目录存储各个槽分组且主键值是有序的于是可以通过二分查找法的方式进行检索从而提高效率为了高效查询记录所在的数据页采用树作为索引每个节点都是一个数据页如果叶子节点存储的是实际数据的就是聚簇索引一个表只能有一个聚簇索引如果叶子节点存储的不是实际数据而是主键值则就是二级索引一个表中可以有多个二级索引在使用二级索引进行查找数据时如果查询的数据能在二级索引找到那么就是索引覆盖操作如果查询的数据不在二级索引里就需要先在二级索引找到主键值需要去聚簇索引中获得数据行这个过程就叫作回表索引失效情况索引之所以会失效需要从他自身结构和排序规则出发去思考根据什么东西建立索引但是却不按照这个来查必会索引失效索引列采用左模糊匹配或左右模糊匹配是因为根据文字列建索引是按照文字内部先后顺序进行排序比如林某先排林再排某相当于整体是对第一个字建了索引和联合索引类似所以直接当第一个字模糊查询时就只能全表查询了根据对索引使用函数在这种情况下索引并不是按照索引函数值而建立索引的所以一定会失效但是可以选择对函数建立索引以达到索引不失效的作用对索引进行表达式计算在这里完全可以对表达式转化而直接对主键进行搜索但是偷懒了所以这里为什么为失效是因为索引是更具建立的而不是这样的表达式而不愿意在搜索层面去简化运算而导致全表扫描对索引隐式类型转换对一个列创建二级索引查询时参数类型和该索引本身类型不一样将会导致索引失效图片图片图片图片使用该段测试得到会把字符转化为数字来搜索结果为联合索引中不遵循最左匹配原则为表名为字段联合索引创建时首要是根据最左索引开始排序然后按创建索引顺序继续根据其他索引字段排序所以联合索引查询必须包含最左索引列在版本之前联合查询时如果包括了同时最左索引列以及其他的联合索引的索引列查询条件首先会按照最左索引匹配然后回表查询主键索引数据中其他的条件是否符合而在之后就直接在层判断之后再决定是否进行回表这样大大的降低了回表次数的操作是索引下推查询条件中包含非索引字段的条件因为是二者选其一所以两个条件必须都得到遍历而非索引字段条件必须执行全表扫描这也导致索引失效使用索引一定会失效吗不一定当表中只包含该普通索引和主键索引时将会对该普通索引进行全表扫描这时候索引就生效了为什么他不走聚簇索引去搜索呢优化器认为当搜索索引列能达到索引覆盖的功能就可以使用该索引这是因为优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多因此选择了全扫描二级索引树的方式查询数据图片图片函数性能比较函数其实是对每一条数据走括号里面的表达式如果不为则加一从而达到记数的作用图片图片字段全表扫描主键当不包含二级索引时计数会走主键索引优化器所为当包含二级索引会走二级索引技术速度更快和主键采取相同的索引搜索方式但是相对于他免去了括号字段读取步骤因而性能主键所以与查询速度一致事务篇事务的几大特性原子性一个事务中的所有操作要么全部完成要么全部不完成不会结束在中间某个环节而且事务在执行过程中发生错误会被回滚到事务开始前的状态就像这个事务从来没有执行过一样就好比买一件商品购买成功时则给商家付了钱商品到手购买失败时则商品在商家手中消费者的钱也没花出去一致性是指事务操作前和操作后数据满足完整性约束数据库保持一致性状态比如用户和用户在银行分别有元和元总共元用户给用户转账元分为两个步骤从的账户扣除元和对的账户增加元一致性就是要求上述步骤操作后最后的结果是用户还有元用户有元总共元而不会出现用户扣除了元但用户未增加的情况该情况用户和均为元总共元隔离性数据库允许多个并发事务同时对其数据进行读写和修改的能力隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致因为多个事务同时使用相同的数据时不会相互干扰每个事务都有一个完整的数据空间对其他并发事务是隔离的也就是说消费者购买商品这个事务是不影响其他消费者购买的持久性事务处理结束后对数据的修改就是永久的即便系统故障也不会丢失引擎通过什么技术来保证事务的这四个特性的呢持久性是通过重做日志来保证的原子性是通过回滚日志来保证的隔离性是通过多版本并发控制或锁机制来保证的一致性则是通过持久性原子性隔离性来保证事务隔离级有哪些并发执行会出现的现象脏读读到其他事务未提交的数据不可重复读前后读取数据不一样幻读前后读取行数不一致图片图片图片图片如何解决可重复读针对快照读普通语句是通过方式解决了幻读因为可重复读隔离级别下事务执行过程中看到的数据一直跟这个事务启动时看到的数据是一致的即使中途有其他事务插入了一条数据是查询不出来这条数据的所以就很好了避免幻读问题针对当前读等语句是通过记录锁间隙锁方式解决了幻读因为当执行语句的时候会加上如果有其他事务在锁范围内插入了一条记录那么这个插入语句就会被阻塞无法成功插入所以就很好了避免幻读问题实现读提交和可重复读行数据在数据可见的情况否则将会根据当前数据行的往下寻找满足条件的数据最小之后在与之间且不在活跃事务列表之中事务可重复读启动事务时生成一个读提交在每次查询时创建一个新的快照读当前读可重复读快照读如何解决幻读如何解决在事务开启之后数据行发生改变这个时候改变的数据行一定是大于该事务的如此该事务对这新增行不可见能完全解决吗不能还有一种情况开启事务时查询行数据不存在但是之间有个事务插入了该数据事务会自动对这条行记录执行更新操作并把该行的设置成当前事务这样再次查询时会查出这条记录当前读如何解决幻读如何解决事务在读取范围中加间隙锁其他事务的更改操作将会阻塞至事务结束能完全解决吗不能事务使用快照读查询在这之后有事务执行插入操作如果事务继续使用快照读将不会发生幻读但这个时候事务手欠采用当前读完了肯定会查出来新的数据行因为他这个加锁是发生在事务插入操作之后的并不会将其阻塞这漏洞真的无孔不入啊可重复读隔离级别并没有彻底解决幻读只是很大程度上避免了幻读现象的发生锁机制的锁主要分为读锁共享和写锁独占全局锁用于备份数据到磁盘获取到全局锁时只能执行读操作获取锁释放锁支持可重复读事务在备份数据时开启事务无论什么时候读取数据都是一样的就能保障备份数据和实际数据相同即使不同可以通过快照去定位到最新数据不支持可重复读事务的引擎在备份数据库时就要使用全局锁的方法表级锁表锁包括共享读锁独占写锁表级别的共享锁也就是读锁读锁可以多线程持有表级别的独占锁也就是写锁元数据锁说一个实例你就明白了假设有一个查询正在执行元数据读锁此时另一个事务尝试执行或等操作元数据写锁在这种情况下第二个事务会被阻塞直到第一个事务完成并释放元数据锁当我们对数据库表进行操作时会自动给这个表加上随事务的生命周期而产生和消亡对一张表进行操作时加的是读锁对一张表做结构变更操作的时候加的是写锁意向锁意向锁是表级锁但与行级锁相关在对行记录加独占锁或者共享锁时需要先加个意向锁可以避免再对每一行记录查询是否占有锁而只查看该表是否包含意向锁达到记录快速加锁的的目的意向锁的目的是为了快速判断表里是否有记录被加锁锁保证自增字段插入时正确自增该锁不是再一个事务提交后才释放而是再执行完插入语句后就会立即释放之后引入轻量级的锁给字段赋值一个自增的值就把这个轻量级锁释放了而不需要等待整个插入语句执行完后才释放锁行级锁普通的语句是依靠做并发控制的不会加锁而想对行加锁可以采用以下语句对读取的记录加共享锁对读取的记录加独占锁锁是伴随事务而产生消亡的所以上述语句必须加上事务或者分类记录锁也就是仅仅把一条记录锁上间隙锁锁定一个范围但是不包含记录本身的组合锁定一个范围并且锁定记录本身记录锁锁住一条记录间隙锁专门为解决可重复读隔离级别下的幻读问题而设计间隙锁之间是兼容的即两个事务可以同时持有包含共同间隙范围的间隙锁并不存在互斥关系因为间隙锁的目的是防止插入幻影记录而提出的当你在一个事务中对某个范围的数据行使用了间隙锁时这个事务本身是可以继续查询修改甚至删除这些数据行的这是因为间隙锁锁定的是数据行之间的间隙而非数据行本身即能保护该记录阻止其他事务对该记录修改又能阻止其他事务将新记录插入到被保护记录前面的间隙中插入意向锁它并不是意向锁它是一种特殊的间隙锁属于行级别锁作用就是想在某一个加了锁的范围中执行插入操作用于标识线程等待的状态是如何加行级锁的加锁的对象是索引加锁的基本单位是它是由记录锁和间隙锁组合而成的唯一索引等值查询存在对的当前记录加记录锁不存在对大于该索引的最小索引采取左右开区间保证最小的间隙锁范围加间隙锁为什么不存在的要加间隙锁呢因为锁是对索引加的不存在的索引因而无法锁住该记录唯一索引范围查询没加索引导致的问题导致全表扫描致使整个表加上了锁对所有事务造成了堵塞小明如何避免呢将设置为对是否加索引做了硬性要求避免索引失效再次导致全表扫描可以加告诉优化器使用哪个索引如何会发生死锁当两个事务查询并查询条件中的数据不存在则会加入间隙锁间隙锁可以共有而插入意向锁是与间隙锁相排斥的于是共有情况下执行插入操作导致两个事务都只能等待对方释放间隙锁从而导致死锁发生如何预防死锁开启主动死锁检测将参数设置为设置事务等待时间是用来设置超时时间的默认值时秒因为对磁盘进行操作十分费时间所以引入了的默认大小为因为一次读取操作是根据页来读取的定位到页之后就会把缓存页加载到中再去定位到行记录缓存页控制块保存的是缓存页的表空间页号缓存页地址链表节点如何管理空闲页定义了一个链表保存的是空闲缓存页的控制块的链表每当需要从磁盘中加载一个页到中时就从链表中取一个空闲的缓存页并把控制块信息填上然后把该缓存页对应的控制块从链表中移除如何提高命中率优化读取的数据放在链表前面固定链表长度淘汰最久未使用的数据预读机制把读取页的连续页加载到区域靠近当前被访问数据的数据在未来很大概率会被访问到防止污染页被访问且区域停留时间超过阈值默认为秒才会移动至区域污染是索引失效时带来的全表搜索导致全部的热点数据被淘汰带来的问题日志篇保障原子性实现事务删除插入更新发生错误事回滚配合机制实现读提交可重复读事务机制保证持久性写入磁盘是顺序写不需要定位到页而写数据需要定位到页是随机写顺序写写入性能比随机写效率好很多这样一条语句执行速率很快然后在利用后台线程把数据真正刷入磁盘类似于异步优化和有什么区别记录了此次事务完成之后的状态记录更新后的值记录了事务执行之前的状态记录更新前的值和有什么区别是存在于中的在未引入之前是用的写入方式不同是全量文件保存满了会创建新的文件用来保存则只会用一个文件保存文件格式不同包含了三种文件格式而保存的是记录的是在某个数据页做了什么修改记录数据修改的指令记录修改的数据根据不同的情况自动使用模式和模式用途不同用于主从复制备份恢复数据库被删除了用恢复用于故障恢复主从复制在事务提交的时候异步发送日志从库收到日志响应成功之后再回放文件主从模型同步异步默认半同步保障至少有一个同步成功并加快反应速率主从分离之后对主库主要进行写操作用于同步从库从库进行读操作这样在写优先于读的情况下写操作占用了主表的表锁也不会影响读操作思考题数据库三大范式数据库设计的三范式超详细详解数据库三范式博客满足范式只要做到一个表只存一种数据基本就可以实现第一范式一个列不能再分一个列不能包含多个属性第二范式非主键字段必须完全依赖于主键主键代表表一条数据的唯一标识类似于学生表的其他字段中只包含学生信息课程表字段中只包含课程信息第三范式非主键字段不能依赖其他非主键字段学生表中如果包含了学院合乎常理但是还包括了学院号码学院号码和学院项目依赖则不可取对比支持行级锁粒度更加细只支持表级锁支持事务并有机制做并发控制不支持事务支持外键不支持外键索引和数据是分开的更适用于写入场景以确保数据的一致性和完整性而更适用于读多写少场景处理大量读场景很快在之前不支持全文索引而支持全文索引查询效率上要高全文索引增快文本检索效率例如保存数据是依靠聚簇索引的聚簇索引叶子结点保存的是数据而采用的是非聚簇索引叶子结点保存的是数据的物理地址索引树是独立的通过辅助键检索无需访问主键的索引树引擎是版本之前的默认引擎支持全文检索压缩空间函数等但是不支持事务和行级锁所以一般用于有大量查询少量插入的场景来使用而且不支持外键并且索引和数据是分开存储的是基于索引建立的和相反它支持事务外键并且通过来支持高并发索引和数据存储在一起简单说一说与的区别命令用于删除整个表及其结构通常用于永久性删除表命令用于根据特定条件删除记录而操作则是清空表中的所有数据大表优化方案数据量大限定数据范围读写分离主表用来读从表用来写垂直分区表结构将列划分为多张关联表优点降低数据量减少次数缺点增加了查询次数水平分区表结构不变采用多张相同结构的表保存数据水平分区尽量选用分库优点水平拆分可以支撑非常大的数据量缺点会带来逻辑部署运维的各种复杂度并且减低跨节点的性能下面补充一下数据库分片的两种常见方案客户端代理分片逻辑在应用端封装在包中通过修改或者封装层来实现中间件代理在应用和数据中间加了一个代理层分片逻辑统一维护在中间件服务中批处理库表设计比如避免联表查询缓存修改配置选择合适的引擎或技术栈分库分表读写分离甚至是升级物理机的配置来优化优化索引优化某个字段查询次数多可以使用覆盖索引减少回表操作只为那些经常出现在子句条件或子句中的列创建索引过度的索引要求更多更复杂的树结构会降低插入性能场景中经常依赖某个字段查询例如一段时间不同种类就可以考虑在该字段建立索引场景优化禁用减少子查询使用关联查询替代避免索引失效的场景最左模糊查询函数查询联合索引中不遵循最左匹配原则使用查询避免使用判断避免使用减少使用或者使用或者关联查询语句替代避免长事务之后执行写操作防止线程阻塞因为写操作受阻塞并且写操作是优先于读操作的这会导致后面的读写线程都会阻塞语句应对索引加条件否则会锁住全表分布式唯一如何解决生成过长且无顺序适用于生成文件名数据库自增两个数据库自增设置不同步长有序但是需要独立部署数据库实例成本高还会有性能瓶颈分布式性能好不依赖于数据库但是引入了新组件美团分布式生成方案美团点评分布式生成系统美团技术团队与关系型数据库区别对比介绍框架对象关系映射对象和关系数据是业务实体的两种表现形式业务实体在内存中表现为对象在数据库中表现为关系数据内存中的对象之间存在关联和继承关系而在数据库中关系数据无法直接表达多对多关联和继承关系因此对象关系映射系统一般以中间件的形式存在主要实现程序对象到关系数据库数据的映射对象对象关系数据库映射对象和数据库的映射优点提高开发效率使开发更加对象化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-09 18:00:44',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">FANSEA</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a><a href="/tags/MQ/" style="font-size: 1.05rem;">MQ<sup>1</sup></a><a href="/tags/NoSQL/" style="font-size: 1.05rem;">NoSQL<sup>2</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>8</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E5%88%9B%E4%B8%9A/" style="font-size: 1.05rem;">创业<sup>1</sup></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">微服务<sup>4</sup></a><a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 1.05rem;">思考<sup>10</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 1.05rem;">技术<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/" style="font-size: 1.05rem;">技术漫谈<sup>21</sup></a><a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 1.05rem;">摄影<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>6</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>7</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>4</sup></a><a href="/tags/%E8%BD%A6%E8%BD%A6/" style="font-size: 1.05rem;">车车<sup>1</sup></a><a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 1.05rem;">金融<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>11</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据库</span></a></span></div></div><h1 class="post-title" itemprop="name headline">MySQL深入浅出</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-08-23T07:42:06.000Z" title="发表于 2024-08-23 15:42:06">2024-08-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-09T10:00:44.917Z" title="更新于 2024-10-09 18:00:44">2024-10-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湘潭"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湘潭</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://fansea0.github.io/2024/08/23/MySQL/"><header><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" tabindex="-1" itemprop="url">数据库</a><h1 id="CrawlerTitle" itemprop="name headline">MySQL深入浅出</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">FANSEA</span><time itemprop="dateCreated datePublished" datetime="2024-08-23T07:42:06.000Z" title="发表于 2024-08-23 15:42:06">2024-08-23</time><time itemprop="dateCreated datePublished" datetime="2024-10-09T10:00:44.917Z" title="更新于 2024-10-09 18:00:44">2024-10-09</time></header><h1 id="MySQL深入浅出"><a href="#MySQL深入浅出" class="headerlink" title="MySQL深入浅出"></a>MySQL深入浅出</h1><blockquote>
<p>MySQL其实没那么神秘，也就是一个应用程序，他像其他程序一样共用电脑的CPU内存以及硬盘，但是他主要的作用就是提供了一套很适用于软件数据的数据存储结构存储方案，以及完善的增删改查机制，和一些高级功能能适配很多场景的开发</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240604092920781.png" alt="image-20240604092920781"></p>
<h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><h3 id="第一范式：原子性"><a href="#第一范式：原子性" class="headerlink" title="第一范式：原子性"></a>第一范式：原子性</h3><p><strong>存储的数据应该具有<code>不可再分性</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/b423686c094c01cce4ed6cc205f8c34d.png" alt="b423686c094c01cce4ed6cc205f8c34d"></p>
<h3 id="第二范式：唯一性"><a href="#第二范式：唯一性" class="headerlink" title="第二范式：唯一性"></a>第二范式：唯一性</h3><p><strong><code>非主键</code>字段的值必须<code>完全依赖主键</code></strong></p>
<blockquote>
<p>一般这种情况需要做分表，下图为User表但是包含了课程的信息，非主键字段(<code>课表信息的字段</code>)并未全依赖主键字段，这是冗余的应该拆分出来</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240927161021610.png" alt="image-20240927161021610"></p>
<h3 id="第三范式：独立性"><a href="#第三范式：独立性" class="headerlink" title="第三范式：独立性"></a>第三范式：独立性</h3><p><strong>消除传递依赖(非主键值不依赖于另一个非主键值)</strong></p>
<blockquote>
<p>非主键字段之间产生依赖</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240927161643235.png" alt="image-20240927161643235"></p>
<blockquote>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4></blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/ad1adecd293282999c74616817cc57e6.png" alt="ad1adecd293282999c74616817cc57e6"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/d68068d8187f91fc1c8ad58774831925.png" alt="d68068d8187f91fc1c8ad58774831925"></p>
<h2 id="MySQL知识小站"><a href="#MySQL知识小站" class="headerlink" title="MySQL知识小站"></a>MySQL知识小站</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014191624/article/details/120148354">MySQL中的聚簇索引、非聚簇索引、联合索引和唯一索引_mysql唯一索引是聚簇索引吗-CSDN博客</a></p>
<h3 id="设计库模板"><a href="#设计库模板" class="headerlink" title="设计库模板"></a>设计库模板</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `product`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `product_no` <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个数据类型中：</p>
<ul>
<li><code>10</code> 表示数字的总位数（包括小数点前的部分和小数点后的部分）。</li>
<li><code>2</code> 表示小数点后的位数。</li>
</ul>
</blockquote>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><blockquote>
<p>区别于主键索引，单个列的索引，比如<code>name</code>，也称为普通索引</p>
<p>这种索引允许同一索引列中存在重复的值。也可以为null</p>
</blockquote>
<p><strong>在电商平台的用户行为数据分析中，可以根据用户ID和商品类别建立二级索引，以便快速查询某个用户在某个商品类别下的行为数据</strong></p>
<h3 id="（非）聚簇索引"><a href="#（非）聚簇索引" class="headerlink" title="（非）聚簇索引"></a>（非）聚簇索引</h3><ul>
<li><strong>聚簇索引</strong>：也叫主键索引，是将索引和数据放在一起，聚簇索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；找到索引也就找到了数据。<strong>一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引</strong>。</li>
<li><strong>非聚簇索引</strong>：是指二级索引，也叫<strong>辅助索引</strong>。通过非聚簇索引可以查到记录对应的主键值，再使用主键的值通过聚簇索引找到要查找的数据。</li>
</ul>
<p>Innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据</strong>。</p>
<p>意思是说仅仅根据索引建立的b+树就能查到数据，无需进行回表操作，叫覆盖索引</p>
</blockquote>
<h2 id="开篇第一问"><a href="#开篇第一问" class="headerlink" title="开篇第一问"></a>开篇第一问</h2><p>一个场景题：一个Mysql单表，列是 （唯一id，订单类型，订单时间，金额），一天有三千万条数据，现在要将昨天的数据打印出来，怎么设计索引？具体怎么操作？然后现在要根据订单类型计算每种订单类型的金额总和，怎么操作？</p>
<p>提示：根据时间分，提交多线程；随后追问怎么计算金额总和</p>
<p>对于给定的场景，我们需要设计一个有效的索引策略，以便能够快速检索昨天的数据，并且还要计算每种订单类型的金额总和。</p>
<h3 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h3><p>考虑到查询需求主要是基于订单时间（假设为<code>order_time</code>字段）和订单类型（假设为<code>order_type</code>字段），我们可以设计一个复合索引来优化查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_time_type <span class="keyword">ON</span> your_table_name(order_time, order_type);</span><br></pre></td></tr></table></figure>

<p>这个索引首先按照<code>order_time</code>排序，对于相同的时间，再按照<code>order_type</code>排序。这样设计有几个好处：</p>
<ol>
<li><strong>范围查询优化</strong>：当我们需要查询某个时间段内的数据时（例如昨天的数据），数据库可以利用索引快速定位到这个时间范围。</li>
<li><strong>覆盖索引</strong>：如果查询只需要<code>order_time</code>和<code>order_type</code>字段，那么MySQL可以直接使用索引来满足查询，而无需回表查找。</li>
<li><strong>排序优化</strong>：如果查询需要对结果进行排序，并且排序顺序与索引顺序一致，那么排序操作将非常高效。</li>
</ol>
<h3 id="打印昨天的数据"><a href="#打印昨天的数据" class="headerlink" title="打印昨天的数据"></a>打印昨天的数据</h3><p>要打印昨天的数据，我们可以使用以下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">#CURDATE()函数返回当前日期（不包含时间部分）。</span><br><span class="line">#<span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>从当前日期中减去一天，得到昨天的日期。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> your_table_name</span><br><span class="line"><span class="keyword">WHERE</span> order_time <span class="keyword">BETWEEN</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> <span class="keyword">AND</span> CURDATE()</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>BETWEEN</code>语句来指定时间范围，从昨天的午夜开始到今天的午夜前一秒结束。确保<code>order_time</code>字段是日期时间类型（如<code>DATETIME</code>或<code>TIMESTAMP</code>），以便能够正确地进行比较。</p>
<h3 id="根据订单类型计算金额总和"><a href="#根据订单类型计算金额总和" class="headerlink" title="根据订单类型计算金额总和"></a>根据订单类型计算金额总和</h3><p>要计算每种订单类型的金额总和，我们可以使用<code>GROUP BY</code>语句和聚合函数<code>SUM</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_type, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> your_table_name</span><br><span class="line"><span class="keyword">WHERE</span> order_time <span class="keyword">BETWEEN</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> <span class="keyword">AND</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_type;</span><br></pre></td></tr></table></figure>

<p>这个查询会返回每种订单类型及其对应的金额总和。注意，这里我们同样使用了之前定义的时间范围来限制结果集只包含昨天的数据。</p>
<h3 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h3><p>如果数据量非常大，并且服务器有足够的资源，可以考虑使用多线程来并行处理数据。然而，对于MySQL查询来说，通常不需要显式地创建多线程来处理，因为MySQL服务器内部已经为查询优化和执行做了大量的工作。如果确实需要利用多线程来提高性能，那么应该考虑在应用层实现，比如将时间范围划分成多个子区间，每个线程处理一个子区间的数据。</p>
<h3 id="追问：怎么计算金额总和"><a href="#追问：怎么计算金额总和" class="headerlink" title="追问：怎么计算金额总和"></a>追问：怎么计算金额总和</h3><p>在上面的SQL语句中，我们已经展示了如何计算金额总和。通过<code>SUM(amount)</code>，我们可以得到每种订单类型的总金额。这个操作是在SQL查询中直接完成的，MySQL会扫描符合条件的行，并对每一行的<code>amount</code>字段进行求和，然后按照<code>order_type</code>进行分组。</p>
<p>如果数据量非常大，计算过程可能会比较慢，这时可以考虑以下几个优化策略：</p>
<ol>
<li><strong>确保索引有效</strong>：如上所述，确保<code>order_time</code>和<code>order_type</code>字段上有合适的索引，以加速数据的检索和分组。</li>
<li><strong>硬件和配置优化</strong>：根据服务器的硬件配置（如CPU、内存、磁盘I&#x2F;O等）调整MySQL的配置参数，以优化查询性能。</li>
<li><strong>分区表</strong>：如果表非常大，并且经常需要按时间范围查询数据，可以考虑使用MySQL的分区表功能。通过将表按照时间范围进行分区，可以提高查询性能。</li>
<li><strong>定期汇总</strong>：如果订单数据的变更不频繁，可以考虑定期（如每天或每小时）计算并存储订单类型的金额总和，这样就不需要实时计算，而是直接查询预先计算好的结果。</li>
</ol>
<p>记住，在实际应用中，最佳的做法通常取决于具体的数据量、查询频率、硬件资源以及业务需求。因此，在实施任何优化策略之前，最好先进行性能测试和分析，以确定最有效的方案。</p>
<h3 id="应用层实现"><a href="#应用层实现" class="headerlink" title="应用层实现"></a>应用层实现</h3><p>在应用层使用多线程优化数据检索和计算操作，通常涉及将任务划分为多个子任务，并并行执行这些子任务以加快整体处理速度。对于数据库查询和计算订单类型金额总和的场景，可以通过以下步骤实现多线程优化：</p>
<ol>
<li><p><strong>任务分解</strong>：</p>
<ul>
<li>首先，确定哪些部分的任务可以并行执行。在数据库查询的场景中，如果查询的数据量非常大，并且数据库服务器能够支持并发查询，那么可以将查询拆分成多个子查询，每个子查询负责检索一部分数据。</li>
<li>对于计算订单类型金额总和的任务，如果每种订单类型的计算是独立的，那么也可以将这些计算任务分配给不同的线程并行执行。</li>
</ul>
</li>
<li><p><strong>创建线程或线程池</strong>：</p>
<ul>
<li>根据需要创建足够数量的线程或线程池来执行子任务。使用线程池可以避免频繁地创建和销毁线程，从而提高性能。</li>
<li>在Java中，可以使用<code>ExecutorService</code>和<code>ThreadPoolExecutor</code>来创建和管理线程池。</li>
</ul>
</li>
<li><p><strong>分配任务</strong>：</p>
<ul>
<li>将子任务分配给线程池中的线程执行。这通常涉及到将查询条件或计算参数传递给线程。</li>
</ul>
</li>
<li><p><strong>执行数据库查询</strong>：</p>
<ul>
<li>如果查询任务被拆分成多个子查询，每个线程将执行其分配的子查询，并获取结果集。</li>
<li>确保数据库连接是线程安全的，或者为每个线程创建独立的数据库连接。</li>
</ul>
</li>
<li><p><strong>计算金额总和</strong>：</p>
<ul>
<li>对于计算订单类型金额总和的任务，每个线程将处理其分配的订单类型，并计算相应的金额总和。</li>
<li>可以使用线程安全的集合（如<code>ConcurrentHashMap</code>）来存储每个订单类型的计算结果，以便后续合并。</li>
</ul>
</li>
<li><p><strong>合并结果</strong>：</p>
<ul>
<li>当所有线程完成其任务后，需要合并它们的结果。对于数据库查询，这通常意味着将各个子查询的结果集合并成一个完整的结果集。</li>
<li>对于金额总和的计算，需要将各个线程计算的结果相加，得到每种订单类型的总金额。</li>
</ul>
</li>
<li><p><strong>关闭线程池</strong>：</p>
<ul>
<li>一旦所有任务完成并且结果已经合并，关闭线程池以释放资源。</li>
</ul>
</li>
</ol>
<p>以下是一个简化的Java代码示例，展示了如何使用线程池并行执行数据库查询任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个DatabaseClient类用于执行数据库查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Order&gt; <span class="title function_">queryOrdersByTimeRange</span><span class="params">(Date startTime, Date endTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行数据库查询并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ...; <span class="comment">// 返回订单列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Order类代表订单，包含订单类型和金额等字段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    String orderType;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="comment">// ... 其他字段和构造函数等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadedExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        <span class="type">DatabaseClient</span> <span class="variable">databaseClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseClient</span>();</span><br><span class="line">        List&lt;Future&lt;List&lt;Order&gt;&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设我们按时间范围拆分查询任务</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">startTime</span> <span class="operator">=</span> ...; <span class="comment">// 昨天的开始时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">endTime</span> <span class="operator">=</span> ...;   <span class="comment">// 昨天的结束时间（或今天的开始时间）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">4</span>;    <span class="comment">// 假设我们将查询拆分成4个任务</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> (endTime.getTime() - startTime.getTime()) / taskCount;</span><br><span class="line">		<span class="comment">//！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">        <span class="comment">// 好好学学别人如何多线程处理带返回值的任务！❀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">taskStartTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(startTime.getTime() + i * interval);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">taskEndTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(Math.min(startTime.getTime() + (i + <span class="number">1</span>) * interval, endTime.getTime()));</span><br><span class="line">            Future&lt;List&lt;Order&gt;&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> databaseClient.queryOrdersByTimeRange(taskStartTime, taskEndTime);</span><br><span class="line">            &#125;);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成并合并结果</span></span><br><span class="line">        List&lt;Order&gt; allOrders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Order&gt;&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                allOrders.addAll(future.get()); <span class="comment">// 获取每个任务的结果并添加到总列表中，addAll()方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在可以对allOrders进行处理，比如计算每种订单类型的金额总和等</span></span><br><span class="line">         <span class="comment">// 处理allOrders，计算每种订单类型的金额总和  </span></span><br><span class="line">        Map&lt;String, Double&gt; totalAmountByOrderType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (Order order : allOrders) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> order.getOrderType();  </span><br><span class="line">            <span class="type">double</span> <span class="variable">amount</span> <span class="operator">=</span> order.getAmount();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 如果订单类型已经存在于map中，则累加金额；否则，初始化金额为当前订单的金额 ❀</span></span><br><span class="line">            <span class="comment">//！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">            <span class="comment">//这一步getOrDefault()方法恰到好处，查询是否存在键，存在返回值，不存在初始化值为0</span></span><br><span class="line">            totalAmountByOrderType.put(orderType, totalAmountByOrderType.getOrDefault(orderType, <span class="number">0.0</span>) + amount);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 打印每种订单类型的金额总和：MAP的遍历方法！❀</span></span><br><span class="line">        <span class="comment">// ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : totalAmountByOrderType.entrySet()) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Order Type: &quot;</span> + entry.getKey() + <span class="string">&quot;, Total Amount: &quot;</span> + entry.getValue());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引查询-❀"><a href="#索引查询-❀" class="headerlink" title="索引查询 ❀"></a>索引查询 ❀</h2><p>当你说“根据自己创建索引查询”，我理解为你想了解如何根据自己的需求在数据库中创建索引，并如何使用这些索引进行查询。以下是一个简单的例子，说明如何在关系型数据库中（以MySQL为例）创建索引并使用它进行查询。</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>假设我们有一个名为<code>users</code>的表，其中包含<code>id</code>、<code>name</code>和<code>email</code>三个字段。如果我们经常根据<code>email</code>字段进行查询，那么为了提高查询效率，我们可以为<code>email</code>字段创建一个索引。</p>
<ol>
<li><strong>使用<code>CREATE INDEX</code>语句创建索引</strong>：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> users(email);</span><br></pre></td></tr></table></figure>
<p>这条命令会在<code>users</code>表的<code>email</code>字段上创建一个名为<code>idx_email</code>的索引。</p>
<h3 id="使用索引进行查询"><a href="#使用索引进行查询" class="headerlink" title="使用索引进行查询"></a>使用索引进行查询</h3><p>一旦索引创建成功，你就可以在查询中使用它来提高性能。例如，如果你想根据<code>email</code>字段查找用户，你可以这样写查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;example@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL优化器会自动决定是否使用<code>idx_email</code>索引来加速这个查询。如果它认为使用索引比全表扫描更快，它就会使用索引。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>选择性</strong>：索引的选择性越高，其效果通常越好。选择性是指不重复的索引值与总记录数的比率。例如，一个只有<code>true</code>和<code>false</code>两个值的字段可能不是一个好的索引候选，因为它的选择性很低。</li>
<li><strong>维护成本</strong>：每次插入、更新或删除记录时，索引都需要被更新。因此，过多的索引会增加写操作的开销。</li>
<li><strong>覆盖索引</strong>：如果一个查询只需要访问索引中的信息，而不需要回表访问数据行，那么这个查询就被称为“覆盖索引”查询。这种查询通常非常快。</li>
<li><strong>避免过度索引</strong>：只为那些经常出现在<code>WHERE</code>子句、<code>JOIN</code>条件或<code>ORDER BY</code>子句中的列创建索引。</li>
</ul>
<blockquote>
<p><strong>覆盖索引</strong>：</p>
<p><strong>索引就是你需要查询的列话，就不需要在磁盘加载其他数据块了，直接在索引库找到数据返回，减少IO次数，效率非常高！</strong></p>
<p>是指一个索引包含了查询所需的所有列，而无需访问表的实际数据页。当数据库系统执行查询时，通常需要从磁盘中读取数据页到内存中才能进行处理。而如果使用了覆盖索引，由于索引已经包含了查询所需的所有列的值，数据库系统可以直接通过索引来获取这些值，而不需要额外地读取数据页。这样可以减少磁盘I&#x2F;O的次数和数据在内存中的占用，提高查询的效率。</p>
</blockquote>
<p>最后，为了确定你的索引是否有效地提高了查询性能，你可以使用数据库的查询执行计划工具（如MySQL的<code>EXPLAIN</code>语句）来查看查询是如何使用索引的。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><blockquote>
<p>当数据库表中同时建立id索引和name二级索引，数据库索引库会发生什么变化：</p>
<p>当然是对name字段生成一个索引库，如果说叶子节点包含完整的用户记录，索引库多了，将会占用磁盘很大空间，那我们该怎么办呢？</p>
<p>联想一下：id本身建立了索引并叶子节点携带所有数据，查询id是不是非常快，那么是不思路豁然开朗了！我们就可以选择重新建立name索引库，这次索引库叶子节点只包含name和id，数据量大大降低，根据name所查到的id，再去id索引库查询最终数据，因为name并不是一个主键索引，所以可能会有多个name对应结果，这样就需要<strong>回表</strong>，知道查询到对应的id数据为止！</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240323220646465.png" alt="image-20240323220646465"></p>
<blockquote>
<p>所以谈论这么多，联合索引又是什么呢？</p>
<p>相当于<strong>同时创建的两个二级索引</strong>，但是这个二级索引遵循<strong>最左原则</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_customer_order_date ON orders(name, phone);</span><br></pre></td></tr></table></figure>

<p>同样的是根据两个索引加上主键索引id创建索引库，即叶子节点不携带数据，这样的话会首先根据左边的name索引先排序，所以在叶子节点中会<strong>出现相同的节点，这时才会根据phone排序</strong>；所以说相同值的name节点下可能会保存不同的phone；<strong>所以如果直接搜索phone索引是乱序的就不会起作用</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240323221525110.png" alt="image-20240323221525110"></p>
<h2 id="MySQL-执行流程是怎样的？"><a href="#MySQL-执行流程是怎样的？" class="headerlink" title="MySQL 执行流程是怎样的？"></a>MySQL 执行流程是怎样的？</h2><p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p>
<p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240805162242098.png" alt="image-20240805162242098"></p>
<p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><blockquote>
<p>查询表是否存在！</p>
</blockquote>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select id from tb_user where id &gt; 0 and nick_name = &quot;小鱼同学&quot;;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240323165903873.png" alt="image-20240323165903873"></p>
<blockquote>
<p>优化器会在多种索引中使用效率最高的索引 !</p>
</blockquote>
<p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><blockquote>
<p>InnoDB作为存储引擎会调用read_record 方法来根据不同策略来搜素：</p>
<ol>
<li>当搜索条件包含主键索引时，read_record(const,id)方法逐步查询</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(state!=-<span class="number">1</span>)&#123;</span><br><span class="line">    state = read_record(const,id);</span><br><span class="line">&#125;</span><br><span class="line">Integet <span class="title function_">read_record</span><span class="params">(Enum <span class="keyword">enum</span>,Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录</span></span><br><span class="line">    <span class="keyword">if</span>(isResultTrue(id))&#123;</span><br><span class="line">        <span class="comment">//将数据返回给客户端</span></span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当不包含索引时，read_record(all)方法循环查询，查询到匹配的将一个一个返回到客户端</li>
</ol>
</blockquote>
<p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p>
<p>执行器和存储引擎的交互过程：</p>
<ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推</li>
</ul>
<h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><p>以本文开头查询语句为例，看看执行器是怎么工作的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li>
<li>存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li>
<li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li>
</ul>
<p>至此，这个语句就执行完成了。</p>
<h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>举个全表扫描的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product where name = &#x27;iphone&#x27;;</span><br></pre></td></tr></table></figure>

<p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li>
<li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li>
<li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li>
<li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li>
</ul>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><blockquote>
<p>使用在联合索引</p>
</blockquote>
<p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p>
<p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%B7%AF%E9%A3%9E%E8%A1%A8.png" alt="img"></p>
<p>现在有下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。具体原因这里可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">索引常见面试题(opens new window)</a></p>
<p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li>
<li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li>
<li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li>
<li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li>
<li>如此往复，直到存储引擎把表中的所有记录读完。</li>
</ul>
<p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p>
<p>而使用索引下推后，<strong>判断记录的 reward 是否等于 100000 的工作交给了存储引擎层</strong>，过程如下 ：</p>
<ul>
<li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li>
<li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li>
<li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li>
<li>如此往复，直到存储引擎把表中的所有记录读完。</li>
</ul>
<blockquote>
<p><strong>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward &#x3D; 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</strong></p>
</blockquote>
<p>当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h2 id="SQL知识加油站"><a href="#SQL知识加油站" class="headerlink" title="SQL知识加油站"></a>SQL知识加油站</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 查询字段不为null的数据（is null作用相反）</span></span><br><span class="line"><span class="keyword">select</span> name,age ,score <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询姓李的人，%代表任意多少字符，_代表一个字符</span></span><br><span class="line"><span class="keyword">select</span> name,score <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;李%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多条件查询：or、and、not</span></span><br><span class="line"><span class="keyword">select</span> name,score <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%李%&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> score <span class="operator">&gt;</span> <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重查询，多条件去重就会根据组合来去重：distinct</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> class_id ,exam_num <span class="keyword">from</span> student </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排序规则：order by desc、asc</span></span><br><span class="line"><span class="keyword">select</span> name,age,score <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分页截取数据：limit</span></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> age limit <span class="number">1</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 多条件筛选：case when(条件) then 干什么，用于查询赋值给自设字段</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  name,</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">when</span>(age<span class="operator">&gt;</span><span class="number">60</span>) <span class="keyword">then</span> <span class="string">&#x27;老同学&#x27;</span> <span class="keyword">when</span>(age<span class="operator">&lt;=</span><span class="number">60</span> <span class="keyword">and</span> age<span class="operator">&gt;</span><span class="number">20</span>) <span class="keyword">then</span> <span class="string">&#x27;年轻&#x27;</span></span><br><span class="line">  <span class="keyword">when</span>(age<span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">or</span> age <span class="keyword">is</span> <span class="keyword">null</span>) <span class="keyword">then</span> <span class="string">&#x27;小同学&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span> age_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间函数：date()当前日期、datetime()当前日期和时间、time()时间</span></span><br><span class="line"><span class="keyword">select</span> name,datetime() <span class="keyword">as</span> <span class="built_in">current_date</span> <span class="keyword">from</span> student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串处理，将英文大小写：upper(name)、lower(name)</span></span><br><span class="line"><span class="keyword">select</span> id,name,<span class="built_in">upper</span>(name) <span class="keyword">as</span> upper_name <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;热dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合函数：sum、avg、max、min</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(score) <span class="keyword">as</span> total_score,<span class="built_in">avg</span>(score) <span class="keyword">as</span> avg_score,</span><br><span class="line"><span class="built_in">max</span>(score) <span class="keyword">as</span> max_score,<span class="built_in">min</span>(score) <span class="keyword">as</span> min_score  <span class="keyword">from</span> student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组聚合：group by</span></span><br><span class="line"><span class="keyword">select</span> class_id,<span class="built_in">avg</span>(score) <span class="keyword">as</span> avg_score <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> class_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组聚合：多条件分组 group by</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  class_id,</span><br><span class="line">  exam_num,</span><br><span class="line">  <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total_num</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student <span class="keyword">group</span> <span class="keyword">by</span> class_id,exam_num</span><br><span class="line">  </span><br><span class="line"> <span class="comment">-- 分组之后判断：having （不同于where，where是分组之前判断）</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  class_id,</span><br><span class="line">  <span class="built_in">sum</span>(score) <span class="keyword">as</span> total_score</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  class_id</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">  <span class="built_in">sum</span>(score) <span class="operator">&gt;</span> <span class="number">150</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">-- 关联查询：outer join （不用带on，outer join之后的表内容将会以笛卡尔积返回）</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  s.name student_name,</span><br><span class="line">  s.age student_age,</span><br><span class="line">  s.class_id class_id,</span><br><span class="line">  c.name class_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student s,</span><br><span class="line"><span class="keyword">outer</span> <span class="keyword">join</span> class c;</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 关联查询：inner join (只返回两方的交集)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  stu.name <span class="keyword">as</span> student_name,stu.age <span class="keyword">as</span> student_age,stu.class_id,c.name <span class="keyword">as</span> class_name,c.level <span class="keyword">as</span> class_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student stu</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> class c <span class="keyword">on</span> stu.class_id <span class="operator">=</span> c.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关联查询：left join (返回from表的所有值，join表的匹配值)</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  s.name student_name,s.age student_age,s.class_id,c.name class_name,c.level class_level</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  student s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">JOIN</span>  class c <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Having与Where的区别"><a href="#Having与Where的区别" class="headerlink" title="Having与Where的区别"></a>Having与Where的区别</h3><ul>
<li>Having用于分组后对数据的过滤</li>
<li>Where用于分组之前的数据过滤</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://sqlmother.yupi.icu/#/learn/level19">SQL之母 - 免费SQL自学网站 by 程序员鱼皮 (yupi.icu)</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 请在此处输入 SQL</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  class_id,</span><br><span class="line">  <span class="built_in">sum</span>(score) <span class="keyword">as</span> total_score</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  class_id <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  class_id</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">  <span class="built_in">sum</span>(score) <span class="operator">&gt;</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>sum</code>、<code>avg</code>、<code>max</code>、<code>min</code></p>
<blockquote>
<p>根据from的表单数量来计算，如果有分组语句就按分组计算</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(count) <span class="keyword">AS</span> nums <span class="keyword">FROM</span> access_log; <span class="comment">-- count为列</span></span><br><span class="line"><span class="comment">-- 统计最近五年的每一年的nums总数 按年降序</span></span><br><span class="line"><span class="comment">-- 统计每一年的nums总数</span></span><br><span class="line"><span class="comment">-- -- 统计最近五年的每一年的nums总数 按年降序</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">sum</span>( nums ),</span><br><span class="line">	years </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	age </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	years </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	years <span class="keyword">DESC</span> </span><br><span class="line">	LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="查询两个日期之间行"><a href="#查询两个日期之间行" class="headerlink" title="查询两个日期之间行"></a>查询两个日期之间行</h3><p>要查询两个日期之间的数据，你可以使用SQL的<code>BETWEEN</code>操作符，配合日期字段来实现。假设你有一个名为<code>your_table</code>的表，其中有一个日期字段<code>date_column</code>，你可以使用以下SQL查询来获取两个日期之间的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line"><span class="keyword">WHERE</span> date_column <span class="keyword">BETWEEN</span> <span class="string">&#x27;start_date&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;end_date&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的查询中，你需要将<code>your_table</code>替换为你的实际表名，<code>date_column</code>替换为你的实际日期字段名。同时，将<code>start_date</code>和<code>end_date</code>替换为你要查询的起始日期和结束日期。</p>
<p>请确保你提供的日期格式与数据库中存储的日期格式相匹配。通常，日期格式可以是<code>&#39;YYYY-MM-DD&#39;</code>或数据库特定的其他格式。</p>
<p>另外，如果你想要包含起始日期和结束日期在内的数据，上面的查询已经足够了。如果你只想包含起始日期之前的数据，而不包括结束日期，你可以稍微修改查询如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line"><span class="keyword">WHERE</span> date_column <span class="operator">&gt;=</span> <span class="string">&#x27;start_date&#x27;</span> <span class="keyword">AND</span> date_column <span class="operator">&lt;</span> <span class="string">&#x27;end_date&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个查询中，我们使用<code>&gt;=</code>操作符来包含起始日期，并使用<code>&lt;</code>操作符来排除结束日期。这样，你将获得从起始日期开始到结束日期之前的数据。</p>
<h3 id="关联查询-inner-join"><a href="#关联查询-inner-join" class="headerlink" title="关联查询 - inner join"></a>关联查询 - inner join</h3><p>在 SQL 中，INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。</p>
<p>注意，INNER JOIN 只返回两个表中<strong>满足关联条件的交集部分</strong>，即在两个表中都存在的匹配行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  s.name student_name,</span><br><span class="line">  s.age student_age,</span><br><span class="line">  s.class_id class_id,</span><br><span class="line">  c.name class_name,</span><br><span class="line">  c.level class_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student s</span><br><span class="line">  <span class="keyword">join</span> class c <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240327151951963.png" alt="image-20240327151951963"></p>
<h3 id="关联查询-cross-join"><a href="#关联查询-cross-join" class="headerlink" title="关联查询 - cross join"></a>关联查询 - cross join</h3><p>在 SQL 中，关联查询是一种用于联合多个数据表中的数据的查询方式。</p>
<p>其中，<code>CROSS JOIN</code> 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 <strong>每一行</strong> 与右表的 <strong>每一行</strong> 进行组合，返回的结果是两个表的笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name student_name,s.age student_age,s.class_id, c.name class_name</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">JOIN</span> class c;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240327152915920.png" alt="image-20240327152915920"></p>
<h3 id="关联查询-outer-join（left-right）"><a href="#关联查询-outer-join（left-right）" class="headerlink" title="关联查询 - outer join（left &#x2F; right）"></a>关联查询 - outer join（left &#x2F; right）</h3><blockquote>
<p><code>where</code>的优先级低于<code>left join</code></p>
<p>先连表查出合适的数据再用<code>where</code>过滤</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `users` u</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> user_roles us <span class="keyword">on</span> u.user_id <span class="operator">=</span> us.user_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> roles r <span class="keyword">on</span> us.role_id <span class="operator">=</span> r.role_id</span><br><span class="line"><span class="keyword">WHERE</span> r.role_name <span class="operator">=</span> &quot;user&quot;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 SQL 中，OUTER JOIN 是一种关联查询方式，它根据指定的关联条件，将两个表中满足条件的行组合在一起，并 <strong>包含没有匹配的行</strong> </p>
<p>在 OUTER JOIN 中，包括 <strong>LEFT OUTER JOIN 和 RIGHT OUTER JOIN</strong> 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name student_name,s.age student_age,s.class_id,c.name class_name,c.level class_level</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">JOIN</span>  class c <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240327162843180.png" alt="image-20240327162843180"></p>
<p><strong>RBAC</strong>多表查询场景：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据userid查询到用户的权限信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> permissions.perm_name <span class="keyword">FROM</span> `users` </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_roles <span class="keyword">ON</span> users.user_id <span class="operator">=</span> user_roles.user_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> role_permissions <span class="keyword">ON</span> role_permissions.role_id <span class="operator">=</span> user_roles.role_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> permissions <span class="keyword">ON</span> permissions.perm_id <span class="operator">=</span> role_permissions.perm_id</span><br><span class="line"><span class="keyword">WHERE</span> users.user_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Mysql数据是怎么存储的"><a href="#Mysql数据是怎么存储的" class="headerlink" title="Mysql数据是怎么存储的"></a>Mysql数据是怎么存储的</h2><h3 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h3><blockquote>
<p>每一条数据都是按行保存的</p>
</blockquote>
<h3 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h3><blockquote>
<p>16kb <strong>InnoDB 的数据是按「页」为单位来读写的</strong>，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p>页类型：数据页、索引页、undo 日志页、溢出页</p>
</blockquote>
<h3 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h3><blockquote>
<p>B+树每个节点以区划分</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong></p>
</blockquote>
<h3 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h3><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%BA%B2.png"></p>
<h3 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B+Tree vs B Tree"></a><em><strong>B+Tree vs B Tree</strong></em></h3><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p>
<p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p>
<blockquote>
<p>B+Tree的叶子节点采用双链表连接的原因主要有以下几点：</p>
<ol>
<li><strong>有序性</strong>：B+树的叶子节点中存储的是数据，而不是关键字。因此，叶子节点之间必须有一种有序的方式来存储数据。双链表作为一种有序的数据结构，正好满足了这一要求。通过双链表连接，叶子节点可以按照顺序进行排列，使得数据的存储和检索更加有序和高效。</li>
<li><strong>范围查询友好</strong>：B+树中每一层的节点与相邻节点有指针相互连接（双向），这样在类似于&lt;,&gt;的范围查询中提高查询速率</li>
<li><strong>稳定性</strong>：B+树的内节点不存储Key对应的data，只有叶子节点存储了完整的数据信息。这样的设计使得B+树在查询数据时，每次都必须到达叶子节点才能获取数据。虽然这看似增加了查询的复杂度，但实际上却提高了查询的稳定性。因为无论查询哪个数据，查询路径的长度都是相同的（即树的高度），不会出现因为数据在非叶子节点而导致查询路径长度不同的情况。</li>
<li><strong>空间利用率</strong>：B+树的中间节点不存指针，这样同样大小的磁盘页可以容纳更多的节点元素，使得树的高度相对较小。在数据量相同的情况下，B+树比B树更加“矮胖”，查找起来就更快。</li>
</ol>
<p>综上所述，B+Tree的叶子节点采用双链表连接主要是因为双链表具有<strong>有序性、范围查询友好、稳定性高和空间利用率好</strong>等特点，这些特点使得B+树在数据库索引等应用场景中具有优越的性能。</p>
</blockquote>
<h3 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240604093320106.png" alt="image-20240604093320106"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240604093647159.png" alt="image-20240604093647159"></p>
<h3 id="Log文件"><a href="#Log文件" class="headerlink" title="Log文件"></a>Log文件</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="事务恢复"></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><blockquote>
<p>只能在文本类型 CHAR,VARCHAR,TEXT 类型字段上创建全文索引。字段长度比较大时，如果创建普 通索引，在进行 like 模糊查询时效率比较低，这时可以创建全文索引。 MyISAM 和 InnoDB中都可以 使用全文索引。</p>
</blockquote>
<h2 id="读懂explain语句"><a href="#读懂explain语句" class="headerlink" title="读懂explain语句"></a>读懂explain语句</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240725162307863.png" alt="image-20240725162307863"></p>
<ol>
<li><p><strong>id</strong>: 这是选择列表的编号。数值为 <code>1</code> 表示这是一个单一的操作，没有子查询或联合查询等复杂结构。</p>
</li>
<li><p><strong>select_type</strong>: 显示了查询的类型。<code>SIMPLE</code> 表示这是一个简单的 SELECT 语句，没有子查询或 UNION。</p>
</li>
<li><p><strong>table</strong>: 显示所查询的表名。在这里是 <code>user</code> 表。</p>
</li>
<li><p><strong>type</strong>: 这一列显示了访问类型，它描述了 MySQL 如何访问数据。<code>const</code> 表示 MySQL 使用主键或唯一索引查找单行记录。</p>
</li>
<li><p><strong>possible_keys</strong>: 列出可能使用的索引。这里的 <code>PRIMARY</code> 表示可能使用主键索引来优化查询。</p>
</li>
<li><p><strong>key</strong>: 显示实际使用的索引。这里的 <code>PRIMARY</code> 意味着确实使用了主键索引。</p>
</li>
<li><p><strong>key_len</strong>: 显示了使用的索引长度（以字节为单位）。这里的 <code>4</code> 可能意味着主键是一个整型字段。</p>
</li>
<li><p><strong>ref</strong>: 显示了使用哪个字段或常量来查找行。<code>const</code> 指的是使用常量值进行查找。</p>
</li>
<li><p><strong>rows</strong>: 估计需要检查的行数。这里的 <code>1</code> 表明 MySQL 预计只需要检查一行数据。</p>
</li>
<li><p><strong>filtered</strong>: 这个百分比表示经过 WHERE 子句过滤后剩余的行数比例。这里的 <code>100.00</code> 表示没有应用额外的过滤条件，或者说过滤条件已经被索引覆盖。</p>
</li>
</ol>
<p>综合以上信息，这个 <code>EXPLAIN</code> 输出表明 MySQL 计划使用 <code>user</code> 表的主键索引来查找一个确定的行。由于类型是 <code>const</code>，可以推断查询中包含了一个等于某常量值的主键条件，使得 MySQL 能够直接定位到该行而无需扫描整个表。这通常是一个非常高效的查询策略。</p>
<h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><blockquote>
<h3 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h3></blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_customer_orderdate</span><br><span class="line"><span class="keyword">ON</span> orders (customer_id); <span class="comment">-- orders为表名，customer_id为字段</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="创建联合索引"><a href="#创建联合索引" class="headerlink" title="创建联合索引"></a>创建联合索引</h3></blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_customer_orderdate</span><br><span class="line"><span class="keyword">ON</span> orders (customer_id, order_date); <span class="comment">-- orders为表名，customer_id, order_date为字段</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="对函数创建索引"><a href="#对函数创建索引" class="headerlink" title="对函数创建索引"></a>对函数创建索引</h3></blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>



<h2 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h2><h3 id="普通索引可以为NULL吗"><a href="#普通索引可以为NULL吗" class="headerlink" title="普通索引可以为NULL吗"></a>普通索引可以为NULL吗</h3><blockquote>
<p>可以，null作为特殊值处理，<strong>不会聚集在一起</strong>，<strong>并且不会影响唯一性</strong>，<strong>不能用等号搜寻</strong></p>
</blockquote>
<p>在数据库中，普通索引（也称为非唯一索引或B树索引）是可以包含空值（NULL）的。一个字段如果允许NULL值，并且在其上创建了索引，那么这个索引将能够存储和检索NULL值。</p>
<p>但是，有一些重要的点需要注意：</p>
<ol>
<li>如果一个索引字段允许NULL值，那么NULL值会被当作是独立于所有其他值的特殊值来处理。这意味着即使有多个记录的索引字段为NULL，它们也会被视为不同的值，而不会被聚集在一起。</li>
<li>一个索引字段中NULL值的数量不会影响索引的唯一性。即使在一个唯一索引中，多个NULL值也不会引发唯一性冲突，因为数据库系统将NULL视为不可比较的值。</li>
<li>在进行查询时，如果使用<code>IS NULL</code>或<code>IS NOT NULL</code>来查找记录，索引将非常高效。但如果使用等号<code>=</code>来查找NULL值（例如<code>WHERE column = NULL</code>），这是无效的语法，因为NULL不能用等号来比较。</li>
</ol>
<h3 id="说说索引有哪些？"><a href="#说说索引有哪些？" class="headerlink" title="说说索引有哪些？"></a>说说索引有哪些？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image.png" alt="image"></p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<h3 id="innoDB中页内查询"><a href="#innoDB中页内查询" class="headerlink" title="innoDB中页内查询"></a>innoDB中页内查询</h3><blockquote>
<p>innoDB总体根据B+tree以页为单位建立索引库，读写也是以页为单位的；在页的内部包含重要的两个部分：页目录、行记录；页目录将行记录分组记录了索引，以及每组主键最大值，用于二分查找快速定位数据。而在行记录中是以主键大小为顺序连接的链表，时间复杂度为O(n)，innodb为了防止每组链表数目过大，避免产生过多的O(n)低效查询，规定每个组不高于8行数据，以增加适用二分快速查找的页目录索引来尽可能提高页内查询速率</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240723210952610.png" alt="image-20240723210952610"></p>
<h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><blockquote>
<p>B+树非叶子节点是以页为单位存储的，页内包含的是按照主键大小排序好的，当查询某个数据，将会从根节点根据索引开始搜索，在页内使用二分法查找索引，判断搜索的索引的大小在两个索引行之间就定位最小索引对应的下个索引页，最后定位到叶子节点中，使用二分法快速定位记录所在的分组（槽号），最后在分组内采取遍历的方式找到数据</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/%E5%9B%BE%E7%89%87.png" alt="图片"></p>
<blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</li>
<li>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</li>
<li>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</li>
<li>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</li>
<li>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」</li>
</ul>
<h3 id="索引失效情况！"><a href="#索引失效情况！" class="headerlink" title="索引失效情况！"></a>索引失效情况！</h3><blockquote>
<p>索引之所以会失效需要从他自身结构和排序规则出发去思考！根据什么东西建立索引但是却不按照这个来查必会索引失效</p>
</blockquote>
<ol>
<li><strong>索引列采用左模糊匹配或左右模糊匹配</strong></li>
</ol>
<blockquote>
<p>是因为根据文字列建索引是按照文字内部先后顺序进行排序，比如“林某”，先排<code>林</code>再排<code>某</code>，相当于整体是对第一个字建了索引，和联合索引类似，所以直接当第一个字模糊查询时就只能全表查询了</p>
</blockquote>
<ol start="2">
<li><strong>根据对索引使用函数</strong></li>
</ol>
<blockquote>
<p>在这种情况下，索引并不是按照索引函数值而建立索引的，所以一定会失效</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> LENGTH(name)<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是可以选择对函数建立索引，以达到索引不失效的作用</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> key idx_name_length ((length(name)));</span><br><span class="line">EXPLAIN  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> LENGTH(name)<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240725164557533.png" alt="image-20240725164557533"></p>
<ol start="3">
<li><p><strong>对索引进行表达式计算</strong></p>
<blockquote>
<p>在这里mysql完全可以对表达式转化而直接对主键进行搜索，但是mysql偷懒了！</p>
<p>所以这里为什么为失效是因为：索引是更具id建立的而不是id+1这样的表达式，而mysql不愿意在搜索层面去简化运算，而导致全表扫描</p>
</blockquote>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id_u <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240725165239778.png" alt="image-20240725165239778"></p>
<ol start="4">
<li><strong>对索引隐式类型转换</strong></li>
</ol>
<blockquote>
<p>对一个列创建二级索引，查询时参数类型和该索引本身类型不一样将会导致索引失效</p>
</blockquote>
<p>![图片 (1)](..&#x2F;image&#x2F;图片 (1).png)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>

<p>![图片 (2)](..&#x2F;image&#x2F;图片 (2).png)</p>
<p>使用该段sql测试mysql得到：mysql会把字符转化为数字来搜索</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;10&quot; <span class="operator">&gt;</span> <span class="number">9</span> <span class="comment">-- 结果为1</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>联合索引中不遵循最左匹配原则</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_customer_orderdate</span><br><span class="line"><span class="keyword">ON</span> orders (a, b,c); <span class="comment">-- orders为表名，a, b , c为字段</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>联合索引创建时首要是根据最左索引开始排序，然后按创建索引顺序继续根据其他索引字段排序，所以联合索引查询必须包含最左索引列</p>
<p>在5.6版本之前，联合查询时如果包括了同时最左索引列以及其他的联合索引的索引列查询条件，首先会按照最左索引匹配然后回表查询主键索引数据中其他的条件是否符合。而在5.6之后，就直接在Server层判断之后再决定是否进行回表，这样大大的降低了回表次数的操作是<strong>索引下推</strong></p>
</blockquote>
<ol start="6">
<li><strong>OR查询条件中包含非索引字段的条件</strong></li>
</ol>
<blockquote>
<p>因为OR是二者选其一，所以两个条件必须都得到遍历，而非索引字段条件必须执行全表扫描，这也导致索引失效</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240725222632930.png" alt="image-20240725222632930"></p>
<h3 id="MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="MySQL 使用 like “%x“，索引一定会失效吗？"></a>MySQL 使用 like “%x“，索引一定会失效吗？</h3><blockquote>
<p>不一定，当表中<strong>只包含</strong>该<strong>普通</strong>索引和<strong>主键</strong>索引时，mysql将会对该普通索引进行全表扫描，这时候索引就生效了</p>
<p><strong>为什么他不走聚簇索引去搜索呢？</strong>mysql优化器认为当搜索索引列能达到索引覆盖的功能，就可以使用该索引，这是因为 <code>MySQL</code> 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了「<strong>全扫描二级索引树</strong>」的方式查询数据</p>
</blockquote>
<p>![图片 (4)](..&#x2F;image&#x2F;图片 (4).png)</p>
<h3 id="COUNT-函数性能比较"><a href="#COUNT-函数性能比较" class="headerlink" title="COUNT()函数性能比较"></a>COUNT()函数性能比较</h3><p><code>COUNT()</code>函数其实是对每一条数据走括号里面的表达式，如果不为NULL则COUNT加一，从而达到记数的作用</p>
<p>![图片 (6)](..&#x2F;image&#x2F;图片 (6).png)</p>
<blockquote>
<h4 id="COUNT-字段"><a href="#COUNT-字段" class="headerlink" title="COUNT(字段)"></a>COUNT(字段)</h4></blockquote>
<p>全表扫描！</p>
<blockquote>
<h4 id="COUNT-主键"><a href="#COUNT-主键" class="headerlink" title="COUNT(主键)"></a>COUNT(主键)</h4></blockquote>
<ol>
<li>当不包含二级索引时计数会走主键索引（MySQL优化器所为）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240726164957207.png" alt="image-20240726164957207"></p>
<ol start="2">
<li>当包含二级索引会走二级索引技术，<strong>速度更快</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240726165201178.png" alt="image-20240726165201178"></p>
<blockquote>
<h4 id="COUNT-1"><a href="#COUNT-1" class="headerlink" title="COUNT(1)"></a>COUNT(1)</h4></blockquote>
<p>和<code>COUNT(主键)</code>采取相同的索引搜索方式</p>
<p>但是相对于他<code>COUNT(1)</code><strong>免去了括号字段读取步骤</strong>，因而<code>COUNT(1)性能 &gt; COUNT(主键)</code></p>
<blockquote>
<h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4></blockquote>
<p>COUNT(*) &#x3D;&#x3D; COUNT(0),所以与COUNT(1)查询速度一致</p>
<h2 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h2><h3 id="事务的几大特性"><a href="#事务的几大特性" class="headerlink" title="事务的几大特性"></a>事务的几大特性</h3><ul>
<li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li>
<li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li>
<li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li>
<li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p>
<ul>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<h3 id="事务隔离级有哪些"><a href="#事务隔离级有哪些" class="headerlink" title="事务隔离级有哪些"></a>事务隔离级有哪些</h3><p>并发执行会出现的现象：</p>
<ul>
<li>脏读：读到其他事务未提交的数据；</li>
<li>不可重复读：前后读取数据不一样</li>
<li>幻读：前后读取行数不一致</li>
</ul>
<p>![图片 (8)](..&#x2F;image&#x2F;图片 (8).png)</p>
<p>![图片 (9)](..&#x2F;image&#x2F;图片 (9).png)</p>
<h3 id="MySQL如何解决可重复读"><a href="#MySQL如何解决可重复读" class="headerlink" title="MySQL如何解决可重复读"></a>MySQL如何解决可重复读</h3><ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h3 id="MVCC实现读提交和可重复读"><a href="#MVCC实现读提交和可重复读" class="headerlink" title="MVCC实现读提交和可重复读"></a>MVCC实现读提交和可重复读</h3><p>行数据<code>trx_id</code>在<code>ReadView</code> 数据可见的情况，否则将会根据当前数据行的<code>roll_pointer</code>往下寻找满足条件的数据</p>
<ul>
<li>【最小<code>min_trx_id</code>之后】</li>
<li>【在<code>min_trx_id</code>与<code>max_trx_id</code>之间 且不在活跃事务列表 <code>m_ids</code>之中】</li>
<li>【事务id &#x3D;&#x3D; <code>trx_id</code>】</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240731162828316.png" alt="image-20240731162828316"></p>
<ul>
<li><strong>可重复读</strong>：启动事务时生成一个<code>ReadView</code></li>
<li><strong>读提交</strong>：在每次查询时创建一个新的<code>ReadView</code></li>
</ul>
<blockquote>
<ul>
<li>select * from t_test where id &gt; 100 （快照读）</li>
<li>select * from t_test where id &gt; 100 for update（当前读）</li>
</ul>
</blockquote>
<h3 id="可重复读（快照读）如何解决幻读"><a href="#可重复读（快照读）如何解决幻读" class="headerlink" title="可重复读（快照读）如何解决幻读"></a>可重复读（快照读）如何解决幻读</h3><p><strong>如何解决？</strong></p>
<blockquote>
<p>在事务开启之后，数据行发生改变，这个时候改变的数据行<code>trx_id</code>一定是大于该ReadView事务id的，如此该事务对这新增行不可见</p>
</blockquote>
<p><strong>能完全解决吗？</strong>（不能！）</p>
<blockquote>
<p>还有一种情况，开启事务A时查询行数据不存在，但是之间有个事务B插入了该数据，事务A会自动对这条行记录执行更新操作，并把该行的<code>trx_id</code>设置成当前事务id，这样再次查询时会查出这条记录</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240731170000107.png" alt="image-20240731170000107"></p>
<h3 id="当前读如何解决幻读"><a href="#当前读如何解决幻读" class="headerlink" title="当前读如何解决幻读"></a>当前读如何解决幻读</h3><p><strong>如何解决？</strong></p>
<blockquote>
<p>事务A在读取范围中加间隙锁<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/04E62806.png" alt="04E62806">，其他事务的更改操作将会阻塞至事务A结束</p>
</blockquote>
<p><strong>能完全解决吗？</strong>（不能！）</p>
<blockquote>
<p>事务A使用快照读查询，在这之后有事务B执行插入操作，如果事务A继续使用快照读将不会发生幻读，但这个时候事务A手欠采用当前读，完了肯定会查出来新的数据行，因为他这个加锁是发生在事务B插入操作之后的，并不会将其阻塞！这漏洞真的无孔不入啊！</p>
</blockquote>
<p><strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>MySQL的锁主要分为读锁【共享】和写锁【独占】</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote>
<p>用于备份数据到磁盘，获取到全局锁时，只能执行读操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock <span class="comment">-- 获取锁</span></span><br><span class="line">unlock tables <span class="comment">-- 释放锁</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>innodb</code>支持可重复读事务，在备份数据时开启事务无论什么时候读取数据都是一样的，就能保障备份数据和实际数据相同，即使不同可以通过快照去定位到最新数据</li>
<li><code>myisam</code>不支持可重复读事务的引擎，在备份数据库时就要使用全局锁的方法</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><blockquote>
<p>包括【共享读锁】+【独占写锁】</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表级别的共享锁，也就是读锁；读锁可以多线程持有</span></span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级别的独占锁，也就是写锁；</span></span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure>

<h4 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h4><blockquote>
<p>说一个实例你就明白了：假设有一个<code>SELECT</code>查询正在执行（元数据读锁），此时另一个事务尝试执行<code>ALTER TABLE</code>或<code>DROP TABLE</code>等操作（元数据写锁）。在这种情况下，第二个事务会被阻塞，直到第一个事务完成并释放元数据锁。</p>
<p>当我们对数据库表进行操作时，会自动给这个<strong>表</strong>加上 MDL，随事务的生命周期而产生和消亡</p>
</blockquote>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><blockquote>
<p>意向锁是表级锁但与行级锁相关，在对行记录加【独占锁】或者【共享锁】时需要先加个意向锁，可以避免再对每一行记录查询是否占有锁，而只查看该表是否包含意向锁达到记录快速加锁的的目的</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong></p>
</blockquote>
<h4 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h4><blockquote>
<p>保证自增字段插入时ID正确自增，该锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p>MySQL5.1之后：引入<strong>轻量级的锁</strong>，<strong>给 <code>AUTO_INCREMENT</code>字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong></p>
</blockquote>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>普通的select语句是依靠MVCC做并发控制的，不会加锁，而想对行加锁可以采用以下语句，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对读取的记录加共享锁</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="comment">-- 对读取的记录加独占锁</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>锁是伴随事务而产生消亡的，所以上述语句必须加上事务 begin、start transaction 或者 set autocommit &#x3D; 0。</p>
<p><strong>分类：</strong></p>
<ul>
<li><code>Record Lock</code>，记录锁，也就是仅仅把一条记录锁上；</li>
<li><code>Gap Lock</code>，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li><code>Next-Key Lock</code>：<code>Record Lock</code> + <code>Gap Lock</code> 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><blockquote>
<p>记录锁：锁住一条记录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `user` WHERE id_u = 5 FOR UPDATE;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><blockquote>
<p>间隙锁：专门为解决可重复读隔离级别下的幻读问题而设计</p>
<p><strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</strong></p>
</blockquote>
<p>当你在一个事务中对某个范围的数据行使用了间隙锁时，这个事务本身是可以继续查询、修改甚至删除这些数据行的。这是因为间隙锁锁定的是数据行之间的“间隙”而非数据行本身。</p>
<h4 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h4><blockquote>
<p><code>next-key lock</code> &#x3D; <code>Record Lock</code> + <code>Gap Lock</code> </p>
<p>next-key lock 即能<strong>保护该记录</strong>（阻止其他事务对该记录修改），又能阻止其他事务将新记录插入到被保护记录前面的间隙中。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240801163338738.png" alt="image-20240801163338738"></p>
<h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><blockquote>
<p>它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong></p>
<p>作用就是想在某一个加了锁的范围中执行插入操作，用于标识线程等待的状态</p>
</blockquote>
<h3 id="MySQL是如何加行级锁的"><a href="#MySQL是如何加行级锁的" class="headerlink" title="MySQL是如何加行级锁的"></a>MySQL是如何加行级锁的</h3><blockquote>
<p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的</p>
</blockquote>
<h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><ul>
<li>存在：对的当前记录加记录锁</li>
<li>不存在：对大于该索引的最小索引，采取左右开区间，保证最小的间隙锁范围，加间隙锁</li>
</ul>
<blockquote>
<p>为什么不存在的要加间隙锁呢，因为锁是对索引加的，不存在的索引因而无法锁住该记录</p>
</blockquote>
<h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><h3 id="update没加索引导致的问题"><a href="#update没加索引导致的问题" class="headerlink" title="update没加索引导致的问题"></a>update没加索引导致的问题</h3><blockquote>
<p>导致全表扫描，致使整个表加上了锁，对所有事务造成了堵塞</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> &quot;小明&quot;</span><br></pre></td></tr></table></figure>

<p><strong>如何避免呢？</strong></p>
<blockquote>
<ul>
<li>将<code>sql_safe_updates</code>设置为1(对是否加索引做了硬性要求)</li>
<li>避免索引失效再次导致全表扫描，可以加<code>force index([index_name])</code>告诉优化器使用哪个索引</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240805093408756.png" alt="image-20240805093408756"></p>
<h3 id="如何会发生死锁"><a href="#如何会发生死锁" class="headerlink" title="如何会发生死锁"></a>如何会发生死锁</h3><blockquote>
<p>当两个事务查询，并查询条件中的数据不存在，则会加入间隙锁，间隙锁可以共有，而插入意向锁是与间隙锁相排斥的，于是共有情况下执行插入操作，导致两个事务都只能等待对方释放间隙锁，从而导致死锁发生！</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240805110711309.png" alt="image-20240805110711309"></p>
<h3 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h3><ul>
<li><strong>开启主动死锁检测</strong>（将参数 <code>innodb_deadlock_detect</code> 设置为 on）</li>
<li><strong>设置事务等待时间</strong>（<code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒）</li>
</ul>
<h2 id="BufferPool-1"><a href="#BufferPool-1" class="headerlink" title="BufferPool"></a>BufferPool</h2><blockquote>
<p>因为对磁盘进行IO操作十分费时间，所以引入了BufferPool，BufferPool的默认大小为128MB。因为MySQL一次读取操作是根据页来读取的，定位到页之后就会把缓存页加载到BufferPool中，再去定位到行记录</p>
</blockquote>
<h3 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240805165819706.png" alt="image-20240805165819706"></p>
<h3 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h3><blockquote>
<p>保存的是【<strong>缓存页的表空间、页号、缓存页地址、链表节点</strong>】</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240805165604245.png" alt="image-20240805165604245"></p>
<h3 id="如何管理空闲页"><a href="#如何管理空闲页" class="headerlink" title="如何管理空闲页"></a>如何管理空闲页</h3><blockquote>
<p>定义了一个Free链表，<strong>保存的是空闲缓存页的控制块的链表</strong>。每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并把控制块信息填上，然后把该缓存页对应的控制块从 Free 链表中移除</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240805165910575.png" alt="image-20240805165910575"></p>
<h3 id="如何提高命中率"><a href="#如何提高命中率" class="headerlink" title="如何提高命中率"></a>如何提高命中率</h3><blockquote>
<p>优化LRU（Least Recently Used）</p>
<ul>
<li>读取的数据放在链表前面（固定链表长度，淘汰最久未使用的数据）</li>
<li>预读机制：把读取页的连续页加载到Old区域（靠近当前被访问数据的数据，在未来很大概率会被访问到）</li>
<li>防止BufferPool污染：[页被访问」且「 old 区域停留时间超过<code>innodb_old_blocks_time</code> 阈值（默认为1秒）」才会移动至young区域</li>
</ul>
<p>TIP：BufferPool污染是索引失效时带来的全表搜索导致BufferPool全部的热点数据被淘汰带来的问题</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240807151102770.png" alt="image-20240807151102770"></p>
<h2 id="日志篇"><a href="#日志篇" class="headerlink" title="日志篇"></a>日志篇</h2><h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><ul>
<li>保障<strong>原子性</strong>，实现事务（删除，插入，更新）发生错误事回滚</li>
<li>配合<code>MVCC</code>机制实现<strong>读提交、可重复读</strong>事务机制</li>
</ul>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><ul>
<li>保证<strong>持久性</strong></li>
<li><code>redolog</code>写入磁盘是【<strong>顺序写</strong>】不需要定位到页，而写数据需要定位到页是【<strong>随机写</strong>】，顺序写（写入<code>redolog</code>）性能比随机写效率好很多，这样MySQL一条语句执行速率很快，然后在利用后台线程把数据真正刷入磁盘，类似于异步优化</li>
</ul>
<h3 id="undolog和redolog有什么区别？"><a href="#undolog和redolog有什么区别？" class="headerlink" title="undolog和redolog有什么区别？"></a>undolog和redolog有什么区别？</h3><ul>
<li><code>redolog</code>记录了此次事务【完成之后】的状态，记录更新后的值</li>
<li><code>undolog</code>记录了事务【执行之前】的状态，记录更新前的值</li>
</ul>
<h3 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h3><blockquote>
<p>redolog是存在于innoDB中的，在MySQL未引入innoDB之前是用binlog的</p>
</blockquote>
<ul>
<li><p><strong>写入方式不同</strong>：binlog是全量文件，保存满了会创建新的文件用来保存；redolog则只会用一个文件保存</p>
</li>
<li><p><strong>文件格式不同</strong>：binlog包含了<code>STATEMENT、ROW、MIXED</code>三种文件格式；而redolog保存的是记录的是在<strong>某个数据页做了什么修改</strong></p>
<blockquote>
<p>STATEMENT：记录数据修改的指令； ROW：记录修改的数据；MIXED：根据不同的情况自动使用 ROW 模式和 STATEMENT 模式</p>
</blockquote>
</li>
<li><p><strong>用途不同</strong>：binlog用于主从复制，备份恢复（数据库被删除了用binlog恢复）；redolog用于故障恢复</p>
</li>
</ul>
<h3 id="binlog主从复制"><a href="#binlog主从复制" class="headerlink" title="binlog主从复制"></a>binlog主从复制</h3><blockquote>
<p>在事务提交的时候异步发送binlog日志，从库收到日志响应成功之后，再回放binlog文件</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240807145544352.png" alt="image-20240807145544352"></p>
<blockquote>
<p>主从模型：同步，异步（默认），半同步（保障至少有一个同步成功，并加快反应速率）</p>
</blockquote>
<p>主从分离之后：对主库主要进行写操作，用于同步从库；从库进行读操作；这样在MySQL写优先于读的情况下，写操作占用了主表的表锁，也不会影响读操作！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240807145822130.png" alt="image-20240807145822130"></p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A_art_xiang/article/details/113880638">数据库设计的三范式超详细详解_数据库三范式-CSDN博客</a></p>
<p>满足3范式只要做到&#x3D;&#x3D;一个表只存一种数据&#x3D;&#x3D;基本就可以实现</p>
<ul>
<li>第一范式：<strong>一个列不能再分</strong>（一个列不能包含多个属性）</li>
<li>第二范式：<strong>非主键字段必须完全依赖于主键</strong>（主键代表表一条数据的唯一标识，类似于学生表的其他字段中只包含学生信息，课程表字段中只包含课程信息）</li>
<li>第三范式：<strong>非主键字段不能依赖其他非主键字段</strong>（学生表中如果包含了学院合乎常理，但是还包括了学院号码，学院号码和学院项目依赖，则不可取）</li>
</ul>
<h3 id="innoDB对比MyISAM"><a href="#innoDB对比MyISAM" class="headerlink" title="innoDB对比MyISAM"></a>innoDB对比MyISAM</h3><ul>
<li>innoDB支持行级锁（粒度更加细），MyISAM只支持表级锁</li>
<li>innoDB支持事务，并有MVCC机制做并发控制，MyISAM不支持事务</li>
<li>innoDB支持外键，MyISAM不支持外键，索引和数据是分开的</li>
<li>innoDB更适用于写入场景，以确保数据的一致性和完整性；而MyISAM更适用于读多写少场景，处理大量读场景很快</li>
<li>InnoDB <strong>在MySQL5.5之前</strong>不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高（全文索引增快文本检索效率，例如Like）</li>
<li>innoDB保存数据是依靠聚簇索引的，聚簇索引叶子结点保存的是数据；而MyISAM采用的是非聚簇索引，叶子结点保存的是数据的物理地址，<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240806092124875.png" alt="image-20240806092124875"></p>
<p><strong>myisam</strong>引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持<strong>事务</strong>和<strong>行级锁</strong>，所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持<strong>外键</strong>，并且索引和数据是分开存储的。</p>
<p><strong>innodb</strong>是基于B+Tree索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起</p>
<h3 id="简单说一说drop、delete与truncate的区别"><a href="#简单说一说drop、delete与truncate的区别" class="headerlink" title="简单说一说drop、delete与truncate的区别"></a>简单说一说drop、delete与truncate的区别</h3><ul>
<li>drop命令用于删除整个<strong>表及其结构</strong>，通常用于永久性删除表。</li>
<li>delete命令用于根据特定条件<strong>删除记录</strong>，而truncate操作则是清空表中的<strong>所有数据</strong>。</li>
</ul>
<h3 id="大表优化方案（数据量大）"><a href="#大表优化方案（数据量大）" class="headerlink" title="大表优化方案（数据量大）"></a>大表优化方案（数据量大）</h3><ol>
<li>限定数据范围</li>
<li>读&#x2F;写分离（主表用来读，从表用来写）</li>
<li>垂直分区，表结构将列划分为多张关联表</li>
</ol>
<blockquote>
<ul>
<li>优点：降低数据量，减少IO次数</li>
<li>缺点：增加了Join查询次数</li>
</ul>
</blockquote>
<ol start="4">
<li>水平分区，表结构不变，采用多张相同结构的表保存数据（水平分区尽量选用分库）</li>
</ol>
<blockquote>
<ul>
<li>优点：<strong>水平拆分可以支撑非常大的数据量。</strong></li>
<li>缺点：<strong>会带来 逻辑、部署、运维的各种复杂度，并且减低跨节点Join的性能</strong></li>
</ul>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li>客户端代理： 分片逻辑在应用端，封装在<code>JAR</code>包中，通过修改或者封装层来实现。</li>
<li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</li>
</ul>
</blockquote>
<blockquote>
<p>批处理、库表设计（比如避免联表查询）、缓存、修改配置、选择合适的引擎或技术栈、分库分表、读写分离，甚至是升级物理机的配置来优化。</p>
</blockquote>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p><strong>索引优化：</strong></p>
<ol>
<li>某个字段查询次数多，可以使用覆盖索引，减少回表操作</li>
<li>只为那些经常出现在<code>WHERE</code>子句、<code>JOIN</code>条件或<code>ORDER BY</code>子句中的列创建索引</li>
</ol>
<blockquote>
<p>过度的索引要求更多更复杂的b+树结构，会降低插入性能</p>
</blockquote>
<ol start="3">
<li>场景中经常依赖某个字段查询（例如一段时间，不同种类）就可以考虑在该字段建立索引</li>
</ol>
<p><strong>场景优化：</strong></p>
<ol>
<li>禁用<code>select *</code></li>
<li>减少子查询，使用关联查询替代 (<code>join</code>)</li>
<li>避免索引失效的场景（最左模糊查询，函数查询，联合索引中不遵循最左匹配原则，使用OR查询，避免使用NULL判断，避免使用<code>!=</code>）</li>
<li>减少使用 <code>IN</code> 或者 <code>NOT IN</code> ，使用<code>exists ，not exists</code>或者关联查询语句替代 (?)</li>
<li>避免长事务之后执行写操作，防止线程阻塞，因为写操作受阻塞，并且写操作是优先于读操作的，这会导致后面的读写线程都会阻塞</li>
<li><code>update，delete，select for update</code>语句应对索引加条件，否则会锁住全表</li>
</ol>
<h3 id="分布式唯一ID如何解决"><a href="#分布式唯一ID如何解决" class="headerlink" title="分布式唯一ID如何解决"></a>分布式唯一ID如何解决</h3><ul>
<li>UUID生成ID过长且无顺序，适用于生成文件名</li>
<li>数据库自增ID，两个数据库自增设置不同步长，有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li>Redis分布式ID，性能好不依赖于数据库，但是引入了新组件</li>
<li>美团Leaf分布式ID生成方案（<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统 - 美团技术团队 (meituan.com)</a>）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240806104430760.png" alt="image-20240806104430760"></p>
<h3 id="NoSQL与关系型数据库区别"><a href="#NoSQL与关系型数据库区别" class="headerlink" title="NoSQL与关系型数据库区别"></a>NoSQL与关系型数据库区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240901203429958.png" alt="image-20240901203429958"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240901203505711.png" alt="image-20240901203505711"></p>
<h3 id="PostgreSQL对比MySQL"><a href="#PostgreSQL对比MySQL" class="headerlink" title="PostgreSQL对比MySQL"></a>PostgreSQL对比MySQL</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240901205806666.png" alt="image-20240901205806666"></p>
<h3 id="介绍ORM框架"><a href="#介绍ORM框架" class="headerlink" title="介绍ORM框架"></a>介绍ORM框架</h3><blockquote>
<p><strong>对象-关系映射</strong></p>
<p>对象和关系数据是业务实体的两种表现形式，<strong>业务实体</strong>在内存中表现为<strong>对象</strong>，在<strong>数据库</strong>中表现为<strong>关系数据</strong>。内存中的<strong>对象之间存在关联和继承关系</strong>，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
</blockquote>
<ul>
<li>O：<code>Object</code>对象（java对象）</li>
<li>R：<code>Relation</code> 关系（数据库）</li>
<li>M：<code>Mapping</code> 映射 （对象和数据库的映射)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/20160307142645476.png" alt="20160307142645476"></p>
<p><strong>优点：</strong> 提高开发效率、使开发更加对象化</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">FANSEA</div><div class="post-copyright__author_desc">目标明确，只管去做</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://fansea0.github.io/2024/08/23/MySQL/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://fansea0.github.io/2024/08/23/MySQL/')">MySQL深入浅出</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://fansea0.github.io/2024/08/23/MySQL/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=MySQL深入浅出&amp;url=https://fansea0.github.io/2024/08/23/MySQL/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fansea0.github.io" target="_blank">FANSEA</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据库<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/fansea.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/23/Gradle/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Gradle</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/01/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">读书思考（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/03/16/InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="InnoDB存储引擎"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-16</div><div class="title">InnoDB存储引擎</div></div></a></div><div><a href="/2023/10/16/Mybatis-Plus%E8%AF%AD%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="Mybatis—Plus重要知识点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-16</div><div class="title">Mybatis—Plus重要知识点</div></div></a></div><div><a href="/2024/08/22/PostgreSQL/" title="PostgreSQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-22</div><div class="title">PostgreSQL</div></div></a></div><div><a href="/2024/05/22/influxDB/" title="influxDB"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-22</div><div class="title">influxDB</div></div></a></div><div><a href="/2024/06/06/Mybatis%E9%AB%98%E7%BA%A7/" title="Mybatis高级"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-06</div><div class="title">Mybatis高级</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">MySQL深入浅出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">数据库设计的三大范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">第一范式：原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%9A%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">第二范式：唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9A%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">第三范式：独立性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%AB%99"><span class="toc-number">1.2.</span> <span class="toc-text">MySQL知识小站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%BA%93%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.1.</span> <span class="toc-text">设计库模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9D%9E%EF%BC%89%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">（非）聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E9%97%AE"><span class="toc-number">1.3.</span> <span class="toc-text">开篇第一问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">设计索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%98%A8%E5%A4%A9%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">打印昨天的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%AE%A2%E5%8D%95%E7%B1%BB%E5%9E%8B%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D%E6%80%BB%E5%92%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">根据订单类型计算金额总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">使用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D%E6%80%BB%E5%92%8C"><span class="toc-number">1.3.5.</span> <span class="toc-text">追问：怎么计算金额总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">应用层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2-%E2%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text">索引查询 ❀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用索引进行查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">MySQL 执行流程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%89%A7%E8%A1%8C-SQL"><span class="toc-number">1.7.</span> <span class="toc-text">第四步：执行 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">预处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">优化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">执行器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">主键索引查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">全表扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">索引下推</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E7%9F%A5%E8%AF%86%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">1.8.</span> <span class="toc-text">SQL知识加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Having%E4%B8%8EWhere%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.1.</span> <span class="toc-text">Having与Where的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E8%A1%8C"><span class="toc-number">1.8.3.</span> <span class="toc-text">查询两个日期之间行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-inner-join"><span class="toc-number">1.8.4.</span> <span class="toc-text">关联查询 - inner join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-cross-join"><span class="toc-number">1.8.5.</span> <span class="toc-text">关联查询 - cross join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-outer-join%EF%BC%88left-right%EF%BC%89"><span class="toc-number">1.8.6.</span> <span class="toc-text">关联查询 - outer join（left &#x2F; right）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">1.9.</span> <span class="toc-text">Mysql数据是怎么存储的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%EF%BC%88row%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">行（row）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%EF%BC%88page%EF%BC%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">页（page）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%EF%BC%88extent%EF%BC%89"><span class="toc-number">1.9.3.</span> <span class="toc-text">区（extent）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%EF%BC%88segment%EF%BC%89"><span class="toc-number">1.9.4.</span> <span class="toc-text">段（segment）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-vs-B-Tree"><span class="toc-number">1.10.1.</span> <span class="toc-text">B+Tree vs B Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferPool"><span class="toc-number">1.10.2.</span> <span class="toc-text">BufferPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">Log文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.4.</span> <span class="toc-text">全文索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%87%82explain%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.11.</span> <span class="toc-text">读懂explain语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.</span> <span class="toc-text">如何创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.1.</span> <span class="toc-text">创建普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.</span> <span class="toc-text">创建联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.3.</span> <span class="toc-text">对函数创建索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AF%87"><span class="toc-number">1.13.</span> <span class="toc-text">索引篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E4%B8%BANULL%E5%90%97"><span class="toc-number">1.13.1.</span> <span class="toc-text">普通索引可以为NULL吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.13.2.</span> <span class="toc-text">说说索引有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innoDB%E4%B8%AD%E9%A1%B5%E5%86%85%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.13.3.</span> <span class="toc-text">innoDB中页内查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%EF%BC%9F"><span class="toc-number">1.13.4.</span> <span class="toc-text">B+ 树是如何进行查询的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.13.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%EF%BC%81"><span class="toc-number">1.13.6.</span> <span class="toc-text">索引失效情况！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%BD%BF%E7%94%A8-like-%E2%80%9C-x%E2%80%9C%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97%EF%BC%9F"><span class="toc-number">1.13.7.</span> <span class="toc-text">MySQL 使用 like “%x“，索引一定会失效吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COUNT-%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">1.13.8.</span> <span class="toc-text">COUNT()函数性能比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-%E5%AD%97%E6%AE%B5"><span class="toc-number">1.13.8.1.</span> <span class="toc-text">COUNT(字段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-%E4%B8%BB%E9%94%AE"><span class="toc-number">1.13.8.2.</span> <span class="toc-text">COUNT(主键)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-1"><span class="toc-number">1.13.8.3.</span> <span class="toc-text">COUNT(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT"><span class="toc-number">1.13.8.4.</span> <span class="toc-text">COUNT(*)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-number">1.14.</span> <span class="toc-text">事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.14.1.</span> <span class="toc-text">事务的几大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.14.2.</span> <span class="toc-text">事务隔离级有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.14.3.</span> <span class="toc-text">MySQL如何解决可重复读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E8%AF%BB%E6%8F%90%E4%BA%A4%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.14.4.</span> <span class="toc-text">MVCC实现读提交和可重复读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%89%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.14.5.</span> <span class="toc-text">可重复读（快照读）如何解决幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.14.6.</span> <span class="toc-text">当前读如何解决幻读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.15.</span> <span class="toc-text">锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">1.15.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">1.15.2.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88MDL%EF%BC%89"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">元数据锁（MDL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AUTO-INC-%E9%94%81"><span class="toc-number">1.15.2.4.</span> <span class="toc-text">AUTO-INC 锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.15.3.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Record-Lock"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">Record Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gap-Lock"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">Gap Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Next-key-Lock"><span class="toc-number">1.15.3.3.</span> <span class="toc-text">Next-key Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.15.3.4.</span> <span class="toc-text">插入意向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84"><span class="toc-number">1.15.4.</span> <span class="toc-text">MySQL是如何加行级锁的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">唯一索引等值查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">唯一索引范围查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.15.5.</span> <span class="toc-text">update没加索引导致的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">1.15.6.</span> <span class="toc-text">如何会发生死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">1.15.7.</span> <span class="toc-text">如何预防死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BufferPool-1"><span class="toc-number">1.16.</span> <span class="toc-text">BufferPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A1%B5"><span class="toc-number">1.16.1.</span> <span class="toc-text">缓存页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.16.2.</span> <span class="toc-text">控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%A9%BA%E9%97%B2%E9%A1%B5"><span class="toc-number">1.16.3.</span> <span class="toc-text">如何管理空闲页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">1.16.4.</span> <span class="toc-text">如何提高命中率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%AF%87"><span class="toc-number">1.17.</span> <span class="toc-text">日志篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undolog"><span class="toc-number">1.17.1.</span> <span class="toc-text">undolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redolog"><span class="toc-number">1.17.2.</span> <span class="toc-text">redolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undolog%E5%92%8Credolog%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.17.3.</span> <span class="toc-text">undolog和redolog有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E5%92%8C-binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.17.4.</span> <span class="toc-text">redo log 和 binlog 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.17.5.</span> <span class="toc-text">binlog主从复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.18.</span> <span class="toc-text">思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.18.1.</span> <span class="toc-text">数据库三大范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innoDB%E5%AF%B9%E6%AF%94MyISAM"><span class="toc-number">1.18.2.</span> <span class="toc-text">innoDB对比MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E8%AF%B4drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.3.</span> <span class="toc-text">简单说一说drop、delete与truncate的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%EF%BC%88%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%EF%BC%89"><span class="toc-number">1.18.4.</span> <span class="toc-text">大表优化方案（数据量大）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">1.18.5.</span> <span class="toc-text">SQL优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.18.6.</span> <span class="toc-text">分布式唯一ID如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E4%B8%8E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.7.</span> <span class="toc-text">NoSQL与关系型数据库区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostgreSQL%E5%AF%B9%E6%AF%94MySQL"><span class="toc-number">1.18.8.</span> <span class="toc-text">PostgreSQL对比MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8DORM%E6%A1%86%E6%9E%B6"><span class="toc-number">1.18.9.</span> <span class="toc-text">介绍ORM框架</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" title="分布式理论">分布式理论</a><time datetime="2024-09-26T07:22:18.000Z" title="发表于 2024-09-26 15:22:18">2024-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/26/RocketMq/" title="RocketMq">RocketMq</a><time datetime="2024-09-26T05:56:48.000Z" title="发表于 2024-09-26 13:56:48">2024-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/17/%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/" title="技术漫谈">技术漫谈</a><time datetime="2024-09-17T07:03:23.000Z" title="发表于 2024-09-17 15:03:23">2024-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/14/%E7%AE%97%E6%B3%95%E7%AA%81%E7%A0%B4%E8%AE%A1%E5%88%92/" title="算法突破计划">算法突破计划</a><time datetime="2024-09-14T08:07:23.000Z" title="发表于 2024-09-14 16:07:23">2024-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/01/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%80%EF%BC%89/" title="读书思考（一）">读书思考（一）</a><time datetime="2024-09-01T13:06:14.000Z" title="发表于 2024-09-01 21:06:14">2024-09-01</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="FANSEA" target="_blank">FANSEA</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/MQ/" style="font-size: 0.88rem;">MQ<sup>1</sup></a><a href="/tags/NoSQL/" style="font-size: 0.88rem;">NoSQL<sup>2</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>8</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E5%88%9B%E4%B8%9A/" style="font-size: 0.88rem;">创业<sup>1</sup></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">微服务<sup>4</sup></a><a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 0.88rem;">思考<sup>10</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 0.88rem;">技术<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/" style="font-size: 0.88rem;">技术漫谈<sup>21</sup></a><a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 0.88rem;">摄影<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>6</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>7</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>4</sup></a><a href="/tags/%E8%BD%A6%E8%BD%A6/" style="font-size: 0.88rem;">车车<sup>1</sup></a><a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 0.88rem;">金融<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>11</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 FANSEA 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>